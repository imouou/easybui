{"./":{"url":"./","title":"介绍","keywords":"","body":"BUI 官方文档 1.9.x 简介 BUI 是一个专注移动快速开发的跨平台 UI 框架，基于路径式的路由和组件加载，开箱零配置，简单上手，完美嵌入各平台或打包 APP，适合独立开发各种 Webapp，App，轻应用，小程序，公众号，聆客，钉钉…… 订阅号：微信扫码关注不迷路，版本更新及技巧 特点优势 开箱即用 零配置路由 完美还原界面 跨平台适配 轻量化 高性能 按需加载 一次性加载 单页开发（SPA）媲美原生的交互效果 多页开发（MPA）传统开发 模块化开发 组件化开发 基于真实Dom的数据状态管理 DOM 开发 jQuery 开发 ES6 开发 NPM 模块 less or sass ... BUI 还提供百搭在线开发工具，代码提示插件 BUI-Fast，buijs-cli 工程构建工具等。 适用场景 中小型应用 webapp 开发; 微信公众号开发; 微信小程序内嵌 webview 开发; 支付宝，钉钉，淘宝内嵌 webview 开发; demo 交互原型投标; H5推广开发; 第三方打包独立应用 Cordova Flutter DCloud APICloud AppCan ... 谁在使用 移动、电信、地铁、政府、银行等行业。 案例效果 基于 BUI 制作的高保真还原App 交互效果 网易新闻: 耗时半天 QQ: 耗时1天 微信: 耗时2小时 默认的案例及模板都是单页开发，对于理解模块有一定的帮助. 以上案例都可以在官网的资源找到 扫码体验 Demo 下载安卓体验版 立即下载 基于 Dcloud 打包 开发者约定 1. 问题反馈 遇到问题，请先在文档中搜索，如果没有找到结果，请使用issue 反馈，问题反馈尽量配合截图或者使用场景说明，百分百回（拒绝 Q 群及 QQ 私聊等渠道的信息）。 2. 版本更新 cdn1 beta 版地址: 用于修复问题后快速发布,可以下载使用，不建议直接引入地址用于生产环境. https://unpkg.com/buijs/lib/latest/bui.css https://unpkg.com/buijs/lib/latest/bui.js cdn2 beta 版地址: 用于修复问题后快速发布,可以下载使用，不建议直接引入地址用于生产环境. https://cdn.jsdelivr.net/npm/buijs/lib/latest/bui.css https://cdn.jsdelivr.net/npm/buijs/lib/latest/bui.js 如果要指定版本 https://cdn.jsdelivr.net/npm/buijs@1.9.2/lib/latest/bui.js 文档下载 BUI 文档 在线阅读 BUI 在线阅读 链接 BUI 官网 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-12-29 09:16:53 "},"chapter1/quickstart.html":{"url":"chapter1/quickstart.html","title":"快速入门","keywords":"","body":"快速入门 一、安装方式 1. npm 创建开发工程 推荐node环境16.x，复制命令自动安装构建 npx buijs@latest create bui-app 效果预览 2. 下载工程方式 下载单页开发包 修改解压的目录名为 demo， 打开终端命令行。 npm 安装依赖即可预览# 进入工程目录 cd demo # 安装依赖,加上淘宝源会速度快一点，或使用cnpm npm install --registry=https://registry.npm.taobao.org # 运行预览 npm run dev 3. 使用CDN版本 引入cdn依赖即可，CDN可能会不稳定，仅供示例说明。 unpkg.com buijs 1. 新建 index.html 页面 BUI // 多页开发: 一个页面必须要有一个 bui.ready, 且只能有一个 bui.ready(function(global){ // init bui.alert(\"done\") }) 二、开发示例 接着以CDN的开发方式，多页开发，简单说明结构与控件，组件的基本使用，与传统开发保持一致。 新增BUI页面 放在body结构里面。 BUI首页 使用BUI控件 一个控件包含结构与初始化脚本，分别增加到main内容里面，以及bui.ready的初始化里面。 // 轮播图控件初始化 var uiSlide = bui.slide({ id: \"#uiSlide\", height: 380, autopage: true, data: [{ image: \"http://easybui.com/demo/images/banner01.png\", },{ image: \"http://easybui.com/demo/images/banner02.png\", }] }) 完整代码 BUI BUI首页 // 多页开发: 一个页面必须要有一个 bui.ready, 且只能有一个 bui.ready(function(global){ // init // 轮播图控件初始化 var uiSlide = bui.slide({ id: \"#uiSlide\", height: 380, autopage: true, data: [{ image: \"http://easybui.com/demo/images/banner01.png\", },{ image: \"http://easybui.com/demo/images/banner02.png\", }] }) }) 以上是BUI最基础的用法，简单好理解，但随着需求的变更，慢慢就越写越乱，不好维护。需要组件化把可以复用的代码抽离，比方轮播图是可以公共使用的。 新增自定义组件 还是以轮播图组件为例子，抽离原本的代码，做参数合并操作。单页多页都是一样的用法。 组件化以后，需要部署或打开跨域的chrome才能访问。 pages/slide.html pages/slide.js // 组件包装器 loader.define(function(requires, exports, module, global){ // 接收参数 1.6.x 支持 // let props = bui.history.getParams(module.id); // 接收参数 1.7.x 支持 let props = module.props; // 合并默认参数，如果没传参数则使用默认，可以保证组件正常展示。 let params = $.extend(true,{ height: 380, autopage: true, loop: true, data: [{ image: \"http://easybui.com/demo/images/banner01.png\" }] },props); // id比较特殊，需要改成通过component生成的id params.id = `#${module.id} .bui-slide`; // 轮播图控件初始化 const uiSlide = bui.slide(params); // 抛出接口供外部调用 return uiSlide; }) 在页面的任何地方，使用component 标签即可使用。 完整代码： BUI BUI首页 // 多页开发: 一个页面必须要有一个 bui.ready, 且只能有一个 bui.ready(function(global){ // init }) 组件动态传参 部分参数我们通过属性的方式传过去，对象类型的参数则需要动态传过去。 // 动态编译，且只编译一次，参数只传一次 loader.delay({ id:\"#homeSlide\", param: { height: 300, data: [{ image: \"http://easybui.com/demo/images/banner01.png\" }, { image: \"http://easybui.com/demo/images/banner02.png\" }] } }) 完整代码 BUI BUI首页 // 多页开发: 一个页面必须要有一个 bui.ready, 且只能有一个 bui.ready(function(global){ // 动态编译传参，且只编译一次，参数只传一次 loader.delay({ id:\"#homeSlide\", param: { height: 300, data: [{ image: \"http://easybui.com/demo/images/banner01.png\" }, { image: \"http://easybui.com/demo/images/banner02.png\" }] } }) }) 更多内容请继续参考文档或实践。 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-06-14 16:27:07 "},"chapter1/dev.html":{"url":"chapter1/dev.html","title":"开发方式","keywords":"","body":"开发方式 一、单页开发 下载单页开发包 优点：体验好，媲美 app，操控强，按需加载或一次性加载； 缺点：不支持后端语言输出展示，不支持 seo； 单页开发预览需要部署，或者 node 工程的支持，默认需要 3 个文件，。 index.html BUI // router init window.router = bui.router(); bui.ready(function (global) { // router init, will find default page. pages/main/main.html pages/main/main.js router.init({ id: \"#bui-router\", }); }); pages/main/main.html BUI首页 中间按钮 底部按钮 pages/main/main.js 特定的模块包装 loader.define(function (requires, exports, module, global) { // requires: 加载模块 // module: 模块信息 // global: 获取全局方法 bui.alert(\"done\"); }); 二、多页开发 下载多页开发包 优点：简单，支持后端语言输出展示，支持 seo； 缺点：体验较差，无法定制交互及路由操作； index.html BUI BUI首页 中间按钮 底部按钮 bui.ready(function (global) { // init bui.alert(\"done\"); }); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-11-23 11:32:32 "},"chapter1/standard.html":{"url":"chapter1/standard.html","title":"开发规范","keywords":"","body":"开发规范 遵循以下规范，可以高保真还原设计稿。 1. 切图规范 BUI 基于 REM 适配手机,保持跟原生 DPI 一致的缩放效果, 需要把设计稿转换为 750 的设计稿,量取到的值,直接除以 100,便是 rem 值. 量取设计稿内容的大小/100, 转成 rem 单位 .slide { width: 100%; height: 2.7rem; } 2. 目录规范 注意: 工程目录下不能有中文文件名,会影响打包. 整个工程目录也不能有中文路径, 保存代码热更新才会有效. 目录说明: ➜ bui tree . ├── src ## 应用目录 | ├── index.html ## 首页路由结构 | ├── index.js ## 路由初始化 | ├── pages ## 页面存放地址 | │ ├── main | │ | └── main.html ## 默认打开的main模板，代表首页内容（可配） | │ | └── main.js ## 默认打开的main模块，代表首页初始化（可配） | │ └── components (可选) ## 组件目录 | │ └── slide ## slide 组件 | │ └── index.html ## slide 模板 | │ └── index.js ## slide 模块 | ├── js ## 框架及插件目录 | | ├── zepto.js ## zepto库 | | ├── bui.js ## bui库 | │ ├── config (可选) ## 公共配置的文件目录 | │ | └── global.js | │ └── plugins (可选) ## 插件目录，插件必须存放在这里面才不会被二次编译 | │ | └── map ## 地图插件 | │ | └── map.css | │ | └── map.js | │ └── platform (可选) ## 原生的平台框架 | │ └── cordova.js | ├── css ## 应用的样式目录 | | ├── bui.css | | └── style.css | ├── less（可选） ## 使用less写样式，会覆盖掉style.css | | ├── _common.less | | └── style.less | ├── scss（可选） ## 使用scss写样式，会覆盖掉style.css | | ├── _common.scss | | └── style.scss │ ├── font ## bui.css用到的字体图标 │ └── images ## 应用的图片目录 │ ├── app.json ## 编译的配置 ├── gulpfile.js ├── package.json 3. 路径使用规范 假设你的页面在 pages/main/index.html; 单页开发, 使用相对 src 目录的路径, 无论你的页面的层级目录有多深, 里面的图片路径,跳转路径, 应该使用 images/xxx.jpg, pages/xxx/xxx.html 的写法; 不使用绝对根路径的写法 /images/xxx.jpg, /pages/xxx/xxx.html; 打包后本地的路径查找会从 file:///xxxx 来查找你的文件, 最终导致路径错误. 4. 页面结构规范 一个标准的结构包含, .bui-page 子集分别是 header, main, footer 等标签, main 标签必须有, 因为页面初始化的时候会自动撑开 main 的高度. 快速书写 ui-page Tab BUI开发工程模板 5. 模块化规范 一个 js 文件里面只能有一个 loader.define 的匿名模块; 业务逻辑需要在 loader.define 里面,防止加载其它模块的时候冲突; 模块的路径以及资源等,都使用相对路径; 模块里面不能有bui.ready的执行; // 异步模块或组件 loader.define(function (requires, exports, module, global) { // requires: 加载依赖模块 // module: 当前模块的基本信息 // global: 定义的全局方法 return {}; }); 6. 事件绑定 单页开发里面很容易造成事件重复绑定, 模块、组件里面$（全局选择器） 选择器要改成 router.$（单页选择器） 或 bui.$(兼容单页多页) 选择器. // 单页不应该这样绑定 $(\".bui-page\").click(function (e) {}); // 应该使用 router.$(\".bui-page\").click(function (e) { console.log(\"点击了页面\"); }); // 如果使用组件，不确定在单页多页使用，可以使用 bui.$ bui.$(\".bui-page\").click(function (e) { console.log(\"点击了页面\"); }); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-11-23 11:27:13 "},"chapter1/style.html":{"url":"chapter1/style.html","title":"样式规范","keywords":"","body":"样式规范 字体图标 图标内置样式 更多图标预览 样式名 icon 及 icon- 开头默认自带了字体图标的样式, 如果需要自定义图标或引入第三方图标,建议更改样式名为 icons- 或其它命名. 布局样式 布局 子元素 描述 bui-box span1 - span12 弹性布局 bui-box-space span1 - span12 留白弹性布局 bui-box-vertical span1 - span12 垂直方向 bui-box-reverse span1 - span12 反序排列 bui-fluid span1 - span12 流式布局 bui-fluid-space span1 - span12 留白流式布局 bui-fluid-5 span1 流式5列等比布局, 数字支持1-12 bui-fluid-space-5 span1 流式5列等比留白布局, 数字支持1-12 bui-left 左浮动 bui-right 右浮动 bui-clear 清除浮动 布局对齐 布局 子元素 描述 bui-box-center div 块元素水平垂直居中 bui-box-align-center div 水平居中 bui-box-align-left div 居左对齐 bui-box-align-right div 居右对齐 bui-box-align-middle div 垂直居中对齐 bui-box-align-top div 顶部对齐 bui-box-align-bottom div 底部对齐 bui-box-align-justify div 两端对齐 bui-box-align-stretch div 子集高度拉伸等高 全局样式-常用类 样式名 描述 bui-btn- 自定义按钮,后面跟名字,自带bui-btn样式 container-x 左右间隙 container-y 上下间隙 container-xy 上下左右间隙 active 按钮高亮颜色 clearactive 清除按钮高亮,常用于表单 inline 内联元素 round 圆角 noround 没有圆角 ring 圆 large 加大高度 xlarge 超大高度 bui-reset 按钮样式重置 bui-show 显示块元素 bui-hide 隐藏块元素 全局样式-颜色类 样式名 描述 default 默认颜色 primary 页面主颜色 success 一般是绿色 warning 一般是橘红色 danger 列表的分组标题 全局样式-标题类 样式名 描述 page-title 页面标题 title 文章标题 subtitle 文章子标题 section-title 章节标题,常用于页面的模块划分 bui-btn-title 列表的分组标题 item-title 列表的多行标题 item-text 列表的多行内容 全局样式-文本类 样式名 描述 bui-align-left 文本左对齐 bui-align-right 文本右对齐 bui-align-center 文本居中对齐 bui-text-show 文本显示 bui-text-hide 文本超出点点点 bui-box-text-hide 文本2行超出点点点 bui-text-clip 文本超出截断 全局样式-箭头类 样式名 描述 bui-arrow-left 左边箭头,需要父级增加 positon:relative; bui-arrow-right 右边箭头,需要父级增加 positon:relative; bui-arrow-up 顶部箭头,需要父级增加 positon:relative; bui-arrow-down 底部箭头,需要父级增加 positon:relative; 注意事项 active 是控件的公共样式,请通过父层的方式定义 .bui-nav .active{} ,不要直接 .active {} ; BUI的样式单位都需要以 rem 为单位, 也就是量到的px除以100 就能转换成rem, 除了1px 不做转换; 注意: .bui-nav .active{} 也会修改到使用bui-nav的其它控件, 所以如果跟业务相关,请直接加上自己的业务样式进行修改; Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-11-23 11:27:30 "},"chapter1/layout.html":{"url":"chapter1/layout.html","title":"布局","keywords":"","body":"布局 打包的应用开发不推荐使用 flex 布局，有些底层对 flex 的支持不好，bui-box跟 flex 类似，移动端兼容性更好。底下示例展示加了圆角和背景颜色，实际代码是无色无圆角的。 一、弹性布局 弹性布局，不管子集有多少元素，都会在一行展示。 弹性布局-等比 bui-box 例子: 把整行分成 4 份，4=span1+span2+span1，子集可以是 span1-span12 1/4大小 2/4大小 1/4大小 1/4大小 2/4大小 1/4大小 弹性布局-自适应 bui-box 例子: span1 的宽度 = 整行宽度 - 100px, span1称之自适应 宽度100px // 自适应内容 宽度100px // 自适应内容 弹性布局-垂直 bui-box-vertical 例子: span1 的高度 = 整行高度 100px - 30px 高度30px // 自适应内容 高度30px // 自适应内容 弹性布局-反序 bui-box-reverse 例子: 宽度 100px 的 div，在右边展示 宽度100px // 自适应内容 宽度100px // 自适应内容 弹性布局-对齐 弹性布局-绝对居中 bui-box-center 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-水平居中 bui-box-align-center 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-水平居左 bui-box-align-left 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-水平居右 bui-box-align-right 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-垂直居中 bui-box-align-middle 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-顶部对齐 bui-box-align-top 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-底部对齐 bui-box-align-bottom 例子: 宽度100px,高度50px 宽度100px,高度50px 弹性布局-两端对齐 bui-box-align-justify 例子: 宽度100px 宽度100px 宽度100px 宽度100px 弹性布局-子集等高 bui-box-align-stretch 例子: 内容自适应高度内容自适应高度内容自适应高度 文字的高度 根据内容高度等高展示 文字的高度 二、流式 12 列布局 流式布局把一行分为 12 列,后面的数字加起来等于 12 则一行,大于 12 则另起一行. 2/12 4/12 4/12 2/12 4/12 4/12 4/12 2/12 4/12 4/12 2/12 4/12 4/12 4/12 三、流式等列布局 流式等列布局认为子元素全部是等分的,由父层数字决定子集占比,最多 12 列. 1/2大小 1/2大小 1/2大小 1/2大小 四、间隙布局 每种布局都有一种带间隔的布局, 只需在后面加上-space 流式间隙 bui-fluid-space 例子: 1/2大小 1/2大小 1/2大小 1/2大小 流式等比间隙 bui-fluid-space-2 例子: 1/2大小 1/2大小 1/2大小 1/2大小 弹性间隙 bui-box-space 例子: 1/2大小 1/2大小 1/2大小 1/2大小 五、嵌套布局 几种布局之间可以嵌套自身,也可以相互嵌套,实现更复杂的布局. 例子: 流式等列布局,嵌套弹性布局及流式布局 1/4 1/4 1/4 1/4 1/4 1/4 1/4 1/4 例子: 弹性布局,嵌套流式等列布局及流式布局 1/4 1/4 1/4 1/4 1/4 1/4 1/4 1/4 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:27:46 "},"chapter2/controls.html":{"url":"chapter2/controls.html","title":"控件","keywords":"","body":"控件 控件的定义 控件：是封装简化后可嵌入页面的代码，包含 HTML 结构跟 JS 脚本，例如，下面初始化的变量名uiAccordion 称为实例，实例上有方法，通过方法可以操控实例，使用上比较灵活。 一个简单的例子，折叠菜单。 A 折叠菜单B的内容 B 折叠菜单B的内容 // 初始化，id参数对应html的id var uiAccordion = bui.accordion({ id: \"#accordion\", }); // 通过点击可以展开隐藏的内容，也可以调用方法展开全部隐藏内容 uiAccordion.showAll(); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-27 18:54:30 "},"chapter2/template.html":{"url":"chapter2/template.html","title":"模板","keywords":"","body":"模板 模板是一个 html 结构，不能引入脚本。 main.html 单页模板 模板里面可以增加局部样式. 1.7.x 以上版本不会影响全局样式。 .bui-page .bui-bar { background: red; } 单页模板 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-27 18:30:00 "},"chapter2/module.html":{"url":"chapter2/module.html","title":"模块","keywords":"","body":"模块 模块：模块是一个应用里面对局部通用业务的划分，只跟部分业务关联抽离出来的方法。模块只有 .js 文件 特点 特点 BUI 模块 ES6 模块 一次性加载 支持 支持 按需加载 支持 不支持 模块定义 pages/main/cart.js loader.define(function (requires, exports, module, global) { // 只定义返回方法，不在模块中执行 // 缓存购物车数据 let data = []; return { data: data, add(opt) { // 添加购物车方法 data.push(opt); }, remove(id) { // 删除购物车的某个数据 bui.array.delete(data, id, \"id\"); }, }; }); 模块使用 pages/main/main.js 方法 1: 使用依赖前置的方式，模块中都可以调用 loader.define( [\"pages/main/cart\"], function (cart, requires, exports, module, global) { // 业务组件中调用对应的方法 cart.add({ id: \"cart1\", name: \"\", type: \"\", }); } ); 方法 2: 局部使用 loader.define(function (requires, exports, module, global) { // 异步局部使用 loader.require(\"pages/main/cart\", function (cart) { // 业务组件中调用对应的方法 cart.add({ id: \"cart1\", name: \"\", type: \"\", }); }); }); 方法 3: 同步使用 loader.define(async function (requires, exports, module, global) { // 同步: const cart = await loader.require(\"pages/main/cart\"); // 业务组件中调用对应的方法 cart.add({ id: \"cart1\", name: \"\", type: \"\", }); console.log(cart.data); }); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-27 18:31:18 "},"chapter2/component.html":{"url":"chapter2/component.html","title":"组件","keywords":"","body":"组件 组件是由相同名字的模板+模块文件组成，模板使用.html结尾，模块使用.js结尾，默认使用路径名作为组件的名称，无需配置。组件拥有独立交互，独立样式，独立作用域，独立资源，可以被路由加载(bui.router)，局部加载（bui.tab，component）或弹窗加载（bui.page），使用范围更为广泛灵活。 特点 特点 BUI 模块 BUI 组件 html 文件 没有 有 js 文件 有 有 独立作用域 有 有 自执行 没有 有 组件定义 以按钮为例，默认绑定一个事件。 pages/components/btn.html .bui-btn { } 按钮 pages/components/btn.js // 定义一个模块 loader.define(function (requires, exports, module, global) { // 通过 module.id 绑定可以防止组件被重复加载导致重复绑定问题 let mid = module.id; let $module = bui.$(`#${mid}`); let $btn = $module.find(\".bui-btn\"); // 通过对象来描述组件的信息，便于维护 const pageview = { init() { // 绑定事件 this.bind(); }, bind() { $btn.click(function () { alert(\"已经有按钮事件\"); }); return this; }, }; // 自执行 pageview.init(); // 可以抛出组件里面的方法给外部操作，也可以不抛出 return pageview; }); 组件加载及传参 1.静态加载 页面打开的时候，就会自动加载标签上的组件，color 为自定义传给组件的参数 pages/main/main.html 2.动态延迟加载 pages/main/main.html 标签多了个 delay 属性，需要等待主动调用 delay 方法才会加载组件 pages/main/main.js loader.define(function (requires, exports, module, global) { // 动态加载 loader.delay({ id: \"#btn\", param: { color: \"primary\", }, }); }); 3. 组件同步加载 1.7.x 支持，需要工程支持 loader.define(async function (requires, exports, module, global) { // compBtn 组件可以拿到 init, bind 方法； const compBtn = await loader.delay({ id: \"#btn\", param: { color: \"primary\", }, }); }); 组件接收参数 pages/components/btn.js // 定义一个模块 loader.define(function (requires, exports, module, global) { // 1.6.x 通过模块的id来获取不同的参数，所有属性的参数都会被拿到. // var params = bui.history.getParams(module.id); // 1.7.x let params = module.props; // 通过 module.id 绑定可以防止组件被重复加载导致重复绑定问题 let mid = module.id; let $module = bui.$(`#${mid}`); let $btn = $module.find(\".bui-btn\"); // 通过对象来描述组件的信息，便于维护 const pageview = { init() { // 绑定事件 this.bind(params); this.addColor(params); }, addColor(opt) { // 增加样式 opt.color && $btn.addClass(opt.color); }, bind() { let that = this; $btn.click(function (e) { // 如果外部传方法，则点击的时候要执行该方法 params.callback && params.callback.call(that, e); }); return this; }, }; // 自执行 pageview.init(); // 可以抛出组件里面的方法给外部操作，也可以不抛出 return pageview; }); 组件预览及传参 组件可以单独预览，在网址中的路径 index.html# + 组件名的形式； 方式 1: 普通调试 index.html#pages/components/btn index.html#pages/components/btn?color=primary 方式 2: 微信开发的回调域名不允许使用 hash 值，要改成? 的形式 index.html?module=pages/components/btn index.html?module=pages/components/btn&color=primary 效果预览 按钮 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-28 09:13:49 "},"chapter2/router.html":{"url":"chapter2/router.html","title":"路由","keywords":"","body":"路由 更新说明 1.9.x 新增路由状态属性 router-link 激活时，会自动加上 bui-router-active 类名。 首页 路由激活 如果是动态渲染，单页需要再调用 router.active()方法，多页开发调用 bui.activeRouter() 方法。 一、单页路由 单页路由是组件的加载器，把组件以页面切换的形式加载。 效果预览 点击这里体验 路由功能 支持路由零配置; 支持路由单独配置; 支持路由拦截; 支持物理按键后退; 支持预加载; 支持选择不同动画,融入不同平台的切换效果; 支持页面的局部加载; 支持页面传参,获取参数; 支持指定跳入某个页面; 支持缓存,默认已经配置; 支持展示进度条,需要配置; 支持后退刷新; 支持后退多层; 支持后退到指定模块; 支持页面刷新; 支持当前页面替换; 1.1 页面跳转传参 静态跳转 单页开发包的 index.js 默认对按钮绑定了事件，有 href 属性就可以执行跳转。 index.js bui .btn({ id: \"#bui-router\", handle: \".bui-btn,.btn-link\", }) .load(); 跳转的区别 动态跳转 bui.load(option) 例子: bui.load({ url: \"pages/page2/page2.html\", param: { name: \"page2\" } }); 1.2 接收参数 接收到的参数为一个对象 例子: pages/page2/page2.js // 1.7.x 支持以上几种类型，优先组件参数，没有则获取url参数 var params = module.props; // 结果 // params = {name:\"page2\"} // 1.5.x 支持，只支持url参数 // var params = router.getParams(); // 1.6.x 支持, url,及组件的参数统一获取 // var params = bui.history.getParams(module.id); 1.3 页面后退 bui.back(option) 例子: // 普通后退 bui.back(); // 后退局部刷新 bui.back({ callback: function (prevMod) { // 后退到上一个页面，并拿它的方法执行 prevMod.init(); }, }); // 后退2层刷新 bui.back({ index: -2, callback: function () { bui.refresh(); }, }); // 不管在哪层,都可以后退到首页或指定模块 bui.back({ name: \"main\", }); 1.4 页面替换 页面替换不会增加历史记录 例子: bui.load({ url: \"pages/page3/page3.html\", replace: true }); 1.5 局部加载模块 router.loadPart 不再建议使用，局部加载在 1.6.x 有更统一的方式, 查看组件章节. 例子: router.loadPart({ id: \"#part\", url: \"pages/page2/page2.html\", param: {} }); 1.6 预加载 router.preload(option) // 预加载一个页面 router.preload({ url: \"pages/page2/page2.html\" }); // 预加载多个页面 router.preload([ { url: \"pages/page2/page2.html\", }, { url: \"pages/page3/page3.html\", }, ]); 1.7 配置首页地址 src/index.js bui.ready(function (global) { // 修改首页为登录页, 那main代表的就是登录页 router.init({ id: \"#bui-router\", indexModule: { template: \"pages/login/index.html\", script: \"pages/login/index.js\", }, }); }); 1.8 路由拦截 src/index.js const uiStoarge = bui.storage(); // 存储用户登录信息，登录的时候会设置进去，没有则认为没有登录 let userinfo = \"\"; let whiteList = [\"pages/login/index\"]; bui.ready(function (global) { // 修改首页为登录页 router.init({ id: \"#bui-router\", beforeLoad(e) { // 获取用户登录信息，登录的时候会设置进去，没有则认为没有登录 userinfo = uiStoarge.get(\"userinfo\", 0); // 如果不在白名单里，且没有用户登录信息，则跳转到登录页 if (!userinfo && !whiteList.includes(e.target.name)) { bui.hint(\"请登录后访问\"); // 在当前页插入一个登录页 bui.page({ url: \"pages/login/index.html\", }); // // 跳转登录页，登录完后退刷新处理 // bui.load({ // url:\"pages/login/index.html\" // }) return false; } }, }); }); 1.9.0 开始支持在生命周期里后退拦截，包括物理按键后退，手势后退（IOS手势后退体验不佳） loader.define({ loaded(){ // 页面加载 }, beforeLoad(e){ // 可以实现页面逻辑拦截，html已经加载完成，如果需要拦截，在 router.init({ beforeLoad(e){} }) // return false; } beforeDestroy(e){ // 可以实现路由后退拦截 bui.hint(\"您还没有保存\") // 拦截手势 return false; } }) 1.9 页面刷新 bui.refresh(); 1.10 路由全局事件 注意: 建议全局事件都在 src/index.js 定义，避免订阅事件重复加载绑定。 show 事件 页面显示的时候触发，前进后退都会触发当前页的显示 router.on(\"show\", function (e) { // 获取当前页的模块 console.log(e.target); // 获取上一页的模块 console.log(e.prevTarget); }); hide 事件 页面隐藏的时候触发，前进后退都会触发当前页的隐藏 router.on(\"hide\", function (e) { // 获取当前页的模块 console.log(e.target); // 获取上一页的模块 console.log(e.prevTarget); }); complete 事件 页面完成,每次加载完模板都会触发 router.on(\"complete\", function (e) { // 获取当前页的模块 console.log(e.target); // 获取上一页的模块 console.log(e.prevTarget); }); back 事件 router.on(\"back\", function (e) { // 获取当前页的模块 console.log(e.target); // 获取上一页的模块 console.log(e.prevTarget); }); 二、多页路由 多页路由跳转采用替换页面的形式，没有交互动画，跳转及传参后退的使用都跟单页路由保持一致。 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-11-23 13:29:25 "},"chapter2/history.html":{"url":"chapter2/history.html","title":"历史记录","keywords":"","body":"历史记录 多页单页统一使用 bui.history 来获取历史记录，多页的历史记录只会有一个。 获取所有历史记录 bui.history.get // 获取所有, 返回数组 var allHistory = bui.history.get(); // 通过模块名获取某个历史记录, 返回对象 var main = bui.history.get(\"main\"); 获取当前页的记录 bui.history.getLast // 获取所有, 返回对象 var lastHistory = bui.history.getLast(); // 获取最后的页面的实例, exports 是需要模块抛出才会有. var currentDistance = bui.history.getLast(\"exports\"); 获取上一个页面的记录 bui.history.getPrev // 获取上一个页面 var prevHistory = bui.history.getPrev(); // 获取上一个页面的实例, exports 是需要模块抛出才会有. var prevDistance = bui.history.getPrev(\"exports\"); 获取传参 bui.history.getParams // 1.7.x 以后可以使用 module.props 获取 var params = module.props; // 方法1: 如果不确定该模块会被哪种方式使用, 则可以使用这种方式获取. module.id 在loader.define(function(req,ext,module){ }) 的第三个参数 var params = bui.history.getParams(module.id); // 方法2: 获取单页路由或者多页路由的跳转传参 bui.load({url:\"\",param:{}}) var params = bui.history.getParams(\"url\"); // 方法3: 获取以bui.page({url:\"\",param:{}}) 加载的的参数, 通过以下方式获取 var pageParams = bui.history.getParams(\"page\"); // 方法4: 获取以router.loadPart, loader.load , component标签 加载的的参数, 通过以下方式获取 var partParams = bui.history.getParams(\"component\"); 获取弹窗组件的实例 bui.history.getPage 通过 bui.page 加载的模块,使用这个方式获取 例如: var loginPage = bui.page({ url:\"pages/login/login.html\" }) // 可以拿到login实例抛出的方法 var login = bui.history.getPage(\"pages/login/login\");; pages/login/login.js loader.define(function(require,export,module){ var form = { init: function(){ console.log(\"login init\") } } // 执行 form.init(); return form; }) 内部获取弹窗的实例 pages/login/login.js loader.define(function(require,export,module){ var form = { init: function(){ // 内部可以拿到 module.id 来获取弹窗, 进行弹窗的操作. var dialog = bui.history.getPageDialog(module.id); // 关闭操作 // dialog.close(); console.log(dialog) } } // 执行 form.init(); return form; }) 检测页面是否已经加载 bui.history.check var isLogin = bui.history.check(\"pages/login/login.html\"); 检测component是否已经加载 bui.history.checkComponent // tab1 为 component 标签的id var isLoaded = bui.history.check(\"tab1\"); 检测page是否已经加载 bui.history.checkPage // tab1 为 id var isLoaded = bui.history.checkPage(\"tab1\"); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-01-06 10:28:02 "},"chapter2/communication.html":{"url":"chapter2/communication.html","title":"组件通讯","keywords":"","body":"组件通讯 组件同步通讯 1.7.x 以上版本 异步通讯在业务比较复杂的情况下，会增加使用难度，1.7.x 以后推荐使用同步加载组件的方式，需要工程化的支持。 假设 component1,component2,component3 在 pages/components目录下 pages/main/main.html ... ... pages/main/main.js loader.define(function (requires, exports, module, global) { var component1 = null, component2 = null, component3 = null; var pageview = { init: async function(){ // 组件1 component1 = await loader.syncLoad({ id: \"#comp1\", url: \"pages/components/component1/index.html\", param: {}, }); // 组件2 component2 = await loader.syncLoad({ id: \"#comp2\", url: \"pages/components/component2/index.html\", param: {}, }); // 组件3 component3 = await loader.syncLoad({ id: \"#comp3\", url: \"pages/components/component3/index.html\", param: {}, }); // 组件1可以拿到子组件的方法进行操作 // component1.childs1 } } // 初始化 pageview.init(); return pageview; }); component1 组件，里面有 3 个组件 pages/components/component1/index.html ... ... pages/components/component1/index.js loader.define(function (requires, exports, module, global) { var childs1 = null, childs2 = null, childs3 = null; var pageview = { init: async function(){ // 子组件内部兄弟组件的交互 // 组件1-1 childs1 = await loader.syncLoad({ id: \"#child1\", url: \"pages/components/component1/child-1.html\", param: {}, }); // 组件1-2 childs2 = await loader.syncLoad({ id: \"#child2\", url: \"pages/components/component1/child-2.html\", param: {}, }); // 组件1-3 childs3 = await loader.syncLoad({ id: \"#child3\", url: \"pages/components/component1/child-3.html\", param: {}, }); } } // 初始化 pageview.init(); return { childs1, childs2, childs3, }; }); component1 的 child1 组件的定义 pages/components/component1/child-1.html 按钮 pages/components/component1/child-1.js loader.define(function (requires, exports, module, global) { // 1.6.x 通过模块的id来获取不同的参数，所有属性的参数都会被拿到. // var params = bui.history.getParams(module.id); // 1.7.x let params = module.props; // 通过缓存module.id 绑定可以防止组件的重复绑定问题 let mid = module.id; let $btn = router.$(`#${mid}`).find(\".bui-btn\"); // 通过对象来描述组件的信息，便于维护 const pageview = { init() { // 绑定事件 this.bind(params); this.addColor(params); }, addColor(opt) { // 增加样式 opt.color && $btn.addClass(opt.color); }, bind() { let that = this; $btn.click(function (e) { // 如果外部传方法，则点击的时候要执行该方法 params.callback && params.callback.call(that, e); }); return this; }, }; // 自执行 pageview.init(); // 可以抛出组件里面的方法给外部操作，也可以不抛出 return pageview; }); 组件异步通讯 组件异步通讯的开发方式太过零散，已经不推荐了 BUI 1.6.2 以上版本. 路由初始化以后就会去找 main 入口页, 假设main由 3 个组件组成, 会依次,从上到下加载组件, 加载以后再递归查找子组件, 如此反复. 父组件获取子组件 pages/main/main.html pages/main/main.js loader.define(function () { // 监听 多个子组件加载完成就会触发一次 loader.waited([\"searchbar\", \"list\"], function (searchbar, list) { // 拿到子组件实例操作 console.log(searchbar); console.log(list); }); }); 子组件获取父组件 list 组件 pages/components/list/index.js loader.define(function(require,export,module){ // 1.6.1 的方式 // var params = bui.history.getParams(module.id); // var parentComp = bui.history.getComponent(params.parentId); // 1.6.2 的方式 var parentComp = bui.history.getParentComponent(); // 拿到父组件return 出来的方法, 就可以操作父组件. }) 子组件获取页面组件 list 组件 pages/components/list/index.js loader.define(function(require,export,module){ // 无论被嵌套多少层都可以直接获取到页面组件 var pageComp = bui.history.getLast(\"exports\"); }) 兄弟组件 比方页面由 搜索组件, 列表组件 组成, 点击搜索, 要操作列表的方法重新带上关键字请求; 页面组件 pages/main/main.html search 组件 pages/components/search/index.js loader.define(function(require,export,module){ var pageview = { init: function(){ // 这样是获取不到list组件的 refresh 方法, 因为list比search晚加载. // var list = bui.history.getComponent(\"list\"); let mid = module.id; let $module = bui.$(`#${mid}`); let $btn = $module.find(\"#btnSearch\"); $btn.click(function(){ // 在点击的时候可以获取到兄弟list组件. var list = bui.history.getComponent(\"list\"); // 获取搜索的关键字 var keyword = $module.find(\".search-input\").val(); // 调用列表组件的局部属性方法, 把关键字传过去. list.refresh(keyword); }) } } // 初始化 pageview.init(); return pageview }) list 组件 pages/components/list/index.js loader.define(function(require,export,module){ var pageview = { init: function(){ }, refresh: function(keyword){ // 接收到搜索传来的关键字进行请求操作 console.log(keyword) } } // 初始化 pageview.init(); return pageview }) 注意, 搜索组件在初始化直接获取 list 组件, 会获取不到, 因为 list 比 search 晚加载. Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-06-14 15:03:49 "},"chapter2/page.html":{"url":"chapter2/page.html","title":"组件弹窗加载","keywords":"","body":"组件弹窗加载 组件弹窗加载把组件以弹窗的形式加载到当前页。 初始化 *自动加载每次都会加载一个新的页面 var uiPage = bui.page({ url: \"pages/login/login.html\", param: {}, }); *手动加载只加载一次，点击的时候调用打开方式即可 var uiPage = bui.page({ url: \"pages/login/login.html\", param: {}, autoload: false, }); bui.$(\".bui-page\").click(function () { uiPage.open(); }); 参数说明 重要的几个参数说明下, 具体可以查看 bui.page API url [string] 跳转的地址, 可以是模块名; param [object] 跳转的传参 {}; close [boolean] 是否需要关闭的图标, 默认 false | true; autoload [boolean] 自动执行 默认 true | false; syncHistory [boolean] 是否需要同步历史记录, 默认 false | true (如果为 true, bui.back 会退到上一个页面, false 则跳过上一个页面); cache [boolean] 默认 true(只执行一次) | false(每次打开都重新执行); iframe [boolean] 默认 false | true 是否以 iframe 的形式打开, 适合加载远程地址; effect [boolean] 默认 \"fadeInRight\" 跟路由一样打开, 还有一些其它效果, 请查看 bui.toggle API; beforeClose [function] 关闭前执行回调; closed [function] 关闭后执行回调; beforeOpen [function] 打开前执行回调; opened [function] 打开后执行回调; loaded [function] 第一次加载后执行; 接收参数 在被加载的组件内部如何获取参数呢? bui.history.getParams pages/login/login.js loader.define(function(requires,export,module,global){ // 1.7.x var props = module.props; // 方法1: 如果不确定该组件会被哪种方式使用, 则可以使用这种方式获取. // var params = bui.history.getParams(module.id); // 方法2: 获取以bui.page({url:\"\",param:{}}) 加载的的参数, 通过以下方式获取 // var pageParams = bui.history.getParams(\"page\"); }) 获取弹窗加载的实例 获取到的是加载的登录页 login.js 抛出来的实例. bui.history.getPage pages/main/main.js loader.define(function(requires,export,module,global){ // 可以拿到login实例抛出的方法 var login = bui.history.getPage(\"pages/login/login\"); // login 等于 login.js 抛出的form对象 { init:function(){} } }) pages/login/login.js loader.define(function(requires,export,module,global){ var form = { init: function(){ console.log(\"login init\") } } // 执行 form.init(); return form; }) 内部获取弹窗的实例 获取到的是外部bui.page创建的 dialog的实例. 等于 uiPage ; pages/login/login.js loader.define(function(requires,export,module,global){ var form = { init: function(){ // 内部可以拿到 module.id 来获取弹窗, 进行弹窗的操作. var dialog = bui.history.getPageDialog(module.id); // 关闭操作 // dialog.close(); console.log(dialog) } } // 执行 form.init(); return form; }) Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 16:25:19 "},"chapter2/life.html":{"url":"chapter2/life.html","title":"生命周期","keywords":"","body":"单页生命周期 路由原理 这是路由加载的完整过程. 路由加载路线说明 ① 为首页 main 的自定义模块加载, 已经配置了路径指向, 你可以通过 indexModule 参数修改 main 首页的指向; ② 为没有自定义模块的时候, 点击后走相对根路径的同名文件模块; ③ 为跳转已经加载过的模块; ④ 为只有模板,没有同名脚本路径走的路线; 路线 ①: 自定义的 main 模块加载 路线 ②: 点击跳转的页面加载, 默认跳转的路径就是模块名 路线 ③: 已经加载过的页面,只需走 loaded 回调. 路由加载注意事项 打开路由及跳转页面都会先加载模板,再加载脚本; 单页只需要在首页执行一次 bui.ready; 路由的初始化也必须在 bui.ready 里面执行; 模块里面的选择器使用 router.$ 替换 $ ,确保你操作的是当前页面的模块的 dom; 如果需要修改 bui.loader 需要在 window.router 之前; 路由的全局事件, 必须在 index.js 才能使用, 不能放在单独的模块里. 生命周期 1.5.3 新增, 路由跳转页面会触发模块的加载, 从进入页面,跳转页面,后退页面完成一个页面的生命周期. 页面展示的生命周期 这是打开路由第一次加载 main 模块以后触发的加载. 页面跳转后退之间的生命周期 一. 跳转: 1, main 模块 ① 未定义生命周期, 只执行 loaded . 2, main->A 页面 ① A 页面定义了生命周期, 从 beforeCreate -> created -> beforeLoad -> loaded -> show , 这是 A 页面的显示生命周期. ② 从 main->第 2 次跳转到 A 页面的时候, 直接走 beforeLoad -> loaded -> show; 3, A 页面->B 页面, 会执行 A 页面自身的 hide 再跳去 B 页面的 ① beforeCreate -> created -> beforeLoad -> loaded -> show 二. 后退: B->A 页面 B 跟 A 都有自己的生命周期, 后退的时候会先执行 当前页的hide ->beforeDestroy -> destroyed , 然后还会触发 A 页面的 show 方法. A->main 页面 由于 main 没有定义 show 方法, 所以只执行 A 页面的 hide ->beforeDestroy -> destroyed 使用 具体查看模块的定义. 页面模块的生命周期 1.9.0 开始支持在生命周期里后退拦截，包括物理按键后退，手势后退（IOS手势后退体验不佳） loader.define({ loaded(){ // 页面加载的逻辑 // 定义保存状态 this.saveState = false; }, beforeLoad(e){ // 可以实现页面逻辑拦截，html已经加载完成，如果需要拦截，在 router.init({ beforeLoad(e){} }) // return false; } beforeDestroy(e){ // 可以实现物理按键及手势后退页面逻辑拦截 let that = this; if( this.saveState ){ return true }else{ // 可以实现路由后退拦截 bui.confirm(\"您还没有保存，确定保存吗？\",function(e){ if(e.target.innerText == \"确定\"){ that.saveState = true; bui.back(); } }) // 拦截手势 return false; } } }) Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2024-05-01 10:26:23 "},"chapter2/loader.html":{"url":"chapter2/loader.html","title":"模块定义与加载","keywords":"","body":"模块定义与加载 随着应用的功能逐渐丰富,逻辑的复杂度不断的增加,多人协作等问题, BUI 有了自己的模块化方案, 类似requirejs的 AMD. 熟悉requirejs,seajs都可以很好的适应过来. 模块优点 命名冲突 文件依赖 多人协作 可维护性 跨页面共享 window.loader 默认注册给了 bui.loader. 关于 loader 的用法,可以查看 bui.loader API. 定义模块 loader.define loader.define 定义一个匿名模块. loader.define(function (requires, exports, module, global) { // 以下几个参数非必须,如果前面加载了依赖,则这三个参数后移; // requires : 相当于 loader.require, 获取依赖的模块 // module : 拿到当前模块信息 // global : 定义的全局方法 1.7.x支持 // 第1次加载会执行一次，第2次加载只获取引用的方法。 // 模块如果需要给其它模块加载,通过 return 的方式抛出来 return {}; }); 加载模块 loader.require 假设我们定义了一个匿名模块, 是在 pages/page2/目录下, 目录下有 page2.html ,page2.js 两个文件. 则默认匿名模块的 模块名是 pages/page2/page2 会根据.html 文件提取前面路径作为模块名. page2.js loader.define(function (require, exports, module) { // 定义初始化 function init(text) { // console.log(\"init:\"+text) } // 抛出方法及变量给外部访问. return { init: init, pageName: \"page2\", }; }); 现在我们想在刚刚的 main.js 里面加载这个模块,调用 pages/page2/page2 的名称. main.js 依赖前置的方式，加载顺序 page2 -> main loader.define([\"pages/page2/page2\"],function (page2,require, exports, module) { // 执行 page2.init(\"回调执行\"); return { pageName: \"main\", }; }); 按需使用的方式，加载顺序 main -> page2 loader.define(function (require, exports, module) { // 有回调的时候,是会每次都执行 require(\"pages/page2/page2\", function (page2) { page2.init(\"回调执行\"); }); return { pageName: \"main\", }; }); 打开首页的时候,就会加载main.js, main.js 会去加载pages/page2/page2模块,并调用对应的方法. 模块的定义及加载更多用法，请大家自行查阅 bui.loader API 加载文件资源 loader.import 没有经过 define 的第三方资源,又不想全局引用,可以使用loader.import动态引入进来. 例如,图表控件. 例子1: 动态加载单个样式 loader.import(\"main.css\",function(){ // 创建成功以后执行回调 }); 例子2: 动态加载单个脚本 loader.import(\"main.js\",function(){ // 创建成功以后执行回调 }); 例子3: 动态加载多个脚本 loader.import([\"js/plugins/baiduTemplate.js\",\"js/plugins/map.js\"],function(){ // 创建成功以后执行回调 }); 例子4: 1.5.2新增, 动态加载模板,回调每次都执行, 如果放在 loader.require 里面执行,则默认只初始化一次; loader.import(\"pages/ui/list.html\",function(res){ // 拿到模板信息 }); 例子5: 1.5.4新增, 把html,渲染到某个id下,只渲染一次. 有回调也只执行一次 loader.import(\"pages/ui/list.html\",\"#id\",function(res){ // 在渲染模板到#id以后,回调只执行一次 }); 样式的引入没有局部作用域,所以加载样式文件可能会造成影响全局,最好样式还是统一sass模块化管理. 同步加载多个文件 loader.importSync 如果需要同步加载多个文件, 应该使用loader.importSync来替代loader.import; 例子: 动态加载多个脚本; loader.importSync( [\"js/plugins/baiduTemplate.js\", \"js/plugins/map.js\"], function () { // 创建成功以后执行回调 } ); 获取及配置模块 loader.map 可以用于设置或者获取已经加载的模块的相关信息 例子1: 获取所有模块的配置信息 var map = loader.map(); 例子2: 声明单个模块, router路由默认声明了main模块,页面打开会自动加载该模板下的资源,也可以通过map去修改 修改首页,必须在 window.router=bui.router(); 之后; loader.map({ moduleName: \"main\", template: \"pages/main/main.html\", script: \"pages/main/main.js\" }) 例子3: 定义多个模块,并修改路径 loader.map({ baseUrl: \"\", modules: { \"main\": { moduleName: \"main\", template: \"pages/main/main.html\", script: \"pages/main/main.js\" } \"home\": { moduleName: \"home\", template: \"pages/main/home.html\", script: \"pages/main/home.js\" } } }) 注意: 定义了模块名以后,单页跳转则不能使用路径跳转,而需要传模块跳转, 例如, router.load({url:\"home\"}) 如果loader.define的第一个参数有自定义名称, 则还需要通过loader.map配置下模块的路径及模板指向. 获取模块的信息 1.5.3 新增 loader.get var main = loader.get(\"main\"); 设置模块的信息 1.5.3 新增 loader.set 如要设置 main 模块, 必须在 window.router = bui.router() 之后, router.init 之前. loader.set(\"main\", { template: \"pages/login/login.html\", script: \"pages/login/login.js\", }); 页面模块的生命周期 1.5.3 新增. 需要配合路由使用,路由里面会去调用模块定义的生命周期. beforeCreate,create 只在模块第一次创建的时候执行,如果相同模块第 2 次拿的是缓存, 不会触发; beforeLoad,loaded 每次进入页面都会执行, loaded 就相当于 loader.define(function(){}) 里面的 function; show,hide 每次页面前进后退都会分别执行, 可以通过形参拿到 show,hide 的 type 是 load, 还是 back, 默认当前页刷新, 也会触发 show, type 则等于 firstload; beforeDestroy,destroyed 每次后退前跟后退后执行; 注意: beforeLoad 这里 return false 并不能阻止页面跳转及执行, 如果要阻止应该在 bui.load({url:\"\",beforeLoad:function(){ return false; }}). loader.define({ beforeCreate: function () { // 只在创建脚本前执行,缓存的时候不执行 console.log(this.moduleName + \" before create\"); }, created: function () { // 只在创建后执行,缓存的时候不执行 console.log(this.moduleName + \" createed\"); }, beforeLoad: function () { // 页面每次跳转前都会执行 console.log(this.moduleName + \" before load\"); }, loaded: function () { // 页面每次跳转后都会执行 console.log(this.moduleName + \" loaded\"); }, hide: function (e) { // 页面每次跳转后退都会执行当前模块的触发 console.log(this.moduleName + \" hide\"); console.log(e.type); }, show: function (e) { // 页面每次跳转后退都会执行当前模块的触发 console.log(this.moduleName + \" show\"); console.log(e.type); }, beforeDestroy: function () { // 页面每次后退前执行 console.log(this.moduleName + \" before destroy\"); }, destroyed: function () { // 页面每次后退后执行 console.log(this.moduleName + \" destroyed\"); }, }); 当然,你依然可以使用默认最简单的模块创建方式, 只是特殊模块你可以给它自己的生命周期, 比方我在列表页面,进去详情页, 后退到列表页, 是不会刷新的, 之前的方式是在后退的时候执行某个方法. 现在只要在 show 的这个生命周期里, 我可以调用这个页面的某个局部刷新的方法, 不管是前进后退, 都可以执行. 例子: 利用生命周期实现后退刷新. loader.define({ loaded: function () { this.pageview = {}; // 初始化 this.pageview.init = function () {}; // 局部刷新 this.pageview.refresh = function () {}; // 这个是抛出给 loader.require 访问的, 不能return this return this.pageview; }, show: function (e) { // 后退才触发刷新操作 if (e.type == \"back\") { this.pageview.refresh(); } }, }); 比方跳转的页面里面有个定时器, 后退的时候, 需要清理掉这个定时器, 这些是需要自己清除的. loader.define({ loaded: function () { // 页面每次跳转后都会执行 console.log(this.moduleName + \" loaded\"); // 定时刷新 this.timetoRefresh = window.setInterval(function () { // 4秒后执行刷新 }, 2000); }, beforeDestroy: function () { // 页面每次后退前执行 console.log(this.moduleName + \" before destroy\"); if (this.timetoRefresh) { window.clearInterval(this.timetoRefresh); } }, }); 还有一些比较有用的方法, 会在组件那里介绍. 疑难解答 如何抛出当前模块的方法共享 推荐 使用 return 的方式 ; 微信调试的缓存问题怎么解决? 在 index.js 配置bui.loader的 cache 参数 初始化必须在 window.router 前面 window.loader = bui.loader({ cache: false, }); 为什么不直接采用 requirejs 或者 seajs 呢? 这两种方式都有在项目中使用,这样模块的复用及开发方式就无法统一,A 项目开发完的部分模块,可能 B 项目也能用,但两者各自用的模块化方式不同, 这就需要熟悉的人去做一定的修改. 采用我们自己的模块化方式,可以跟 bui.router 路由更好的配合, 后面模块化的公共插件也会越来越多, 这是我们以后希望看到的. 如何定义模块的依赖呢? main.js // 依赖前置, 这种会优先加载完 page2,page3模块以后再执行main的回调. page2,page3 只定义,不执行. loader.define( [\"pages/page2/page2\", \"pages/page3/page3\"], function (page2, page3, require, exports, module) { // 如果需要用到当前模块信息的话, page3后面依次还有 require,exports,module } ); 如何定义一个自定义名字的模块呢? 第 1 种: 第 1 步: 声明自定义模块, 名称需要跟映射的模块名一致 pages/page2/page2.js loader.define(\"page2\", function (require, exports, module) { // 这里是page2的业务逻辑 }); 第 2 步: 在首页 index.html 的 bui.js 下面引入该文件. index.html 第 2 种: 第 1 步: 映射脚本路径 index.js // 映射脚本路径 loader.map({ moduleName: \"page2\", script: \"pages/page2/page2.js\", }); // 把路由实例化给 window.router window.router = bui.router(); bui.ready(function () {}); 第 2 步: 声明自定义模块, 名称需要跟映射的模块名一致 pages/page2/page2.js loader.define(\"page2\", function (require, exports, module) { // 这里是page2的业务逻辑 }); 组件全局方法 npm run build 在新的工程执行这个命令以后，js 文件全部变成了闭包，原本你的 var 声明的全局变量，变成了局部变量，控制面板会抛出一堆错误. 如果有这个情况，建议及早处理. 在 1.6.2 版本. 使用 loader.global() 来定义全局方法. 例子: js/common.js // 定义全局方法 loader.global(function (global) { return { config: {}, getDate: function () { console.log(\"获取日期\"); }, }; }); 全局使用 bui.ready(function (global) { // 1.6.x 全局调用 loader.global().getDate(); // 1.7.x global.getDate(); }); 模块里面调用，新增第 4 个参数. loader.define(function (require, exports, module, global) { // 全局调用 global.getDate(); }); 模块的定义及加载更多用法，请大家自行查阅 bui.loader API Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-11-09 10:35:12 "},"chapter2/global.html":{"url":"chapter2/global.html","title":"公共方法与配置","keywords":"","body":"公共方法与配置 公共方法的定义 我们在 src/js/ 目录下，新建config目录，目录下新建一个global.js文件，内容如下： js/config/global.js loader.global(function(global) { /** * @description: 公共的请求方法 * @param {object} opt 参考 bui.ajax * @param {string} opt.url 必填url地址 默认 \"\" * @param {object} [opt.data] 默认 {} * @param {string} [opt.method] 默认的请求方法 \"GET\" | \"POST\" * @return {*} * @example {*} * global.ajax({ url:\"http://easybui.com/demo/json/shop.json\", data:{} }).then(function(res){ // 成功的时候输出 console.log(res); }) */ function ajax(opt){ // 可以公共处理请求的headers let opts = $.extend(true,{ headers:{\"token\":\"buixxxx\"} },opt); return bui.ajax(opts) } // 一定要抛出这个方法，外部才能调用到 return { ajax: ajax } }) 公共方法的使用 1. 首页引入 src/index.html 2. 首页调用 src/index.js bui.ready(function(global){ // 1.7.0 以上才支持 global.ajax({ url:\"http://easybui.com/demo/json/shop.json\" }).then(function(res){ console.log(res) }) // 1.6.x 支持 loader.global().ajax({ url:\"http://easybui.com/demo/json/shop.json\" }).then(function(res){ console.log(res) }) }) 3. 组件的调用 src/pages/main/main.js loader.define(function(require,exports,module,global){ // 调用得到global的所有方法 var pageview = { getList(opt){ global.ajax(opt).then((result)=>{ // 请求成功就赋值 this.datas = result.data; },function(result,status){ // 失败 console.log(status) }); } } return pageview; }) 公共配置 1. 控件配置 BUI的每个控件都支持默认的配置修改，可以根据业务需要去配置属于自己的交互版本 js/config/global.js loader.global(function(global) { // ajax 的公共配置，这样所有的请求都会加上这个token，一般不建议这样简单粗暴去修改 bui.config.ajax = { headers: { token:\"buixxxxx\" } } // 默认 hint是居中的交互，可以改成全部从底部交互 bui.config.hint = { position: \"bottom\", effect:\"fadeInUp\" } }) 2. 业务配置 js/config/global.js loader.global(function(global) { let baseurl = \"http://easybui.com/\"; let apiurl = baseurl + \"demo/\" return { baseurl: baseurl, apiurl: apiurl, } }) Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-01-06 11:39:44 "},"chapter2/method.html":{"url":"chapter2/method.html","title":"常用方法","keywords":"","body":"常用方法 生成唯一 ID bui.guid() 例子: var gid = bui.guid(); 类型检测 bui.typeof(str) 返回字符串,全部是小写. 弥补 typeof 无法检测是否是索引对象的问题, null 本身也会返回 object. 例子: var obj = { id: 123, }; var objectStr = bui.typeof(obj); // \"object\" var nullStr = bui.typeof(null); // \"null\" var undefinedStr = bui.typeof(undefined); // \"undefined\" 平台检测 bui.platform 通过 navigator.userAgent 判断当前的平台类型. 方法名采用驼峰氏命名. 例子: bui.platform.isIphone(); bui.platform.isIphoneX(); bui.platform.isIpad(); bui.platform.isWeiXin(); // 平台类 bui.platform.isIos(); bui.platform.isAndroid(); bui.platform.isMac(); bui.platform.isWindow(); 版本检查 bui.checkVersion(option) 这个方法会绑定 ID 按钮的点击,并且第一次会请求到如果有新版本的时候,会在按钮旁边增加个红点, 如果按钮里面还有图标icon,则红点会增加在图标上. 例子: bui.checkVersion({ id: \"#checkUpdate\", currentVersion: \"\", currentVersionCode: \"\", url: \"http://www.easybui.com/json/versionUpdate.json\", }); 请求的接口返回的 json 内容 { \"versionName\": \"1.0\", //版本名称 \"versionCode\": 20160605, //版本ID \"minVersionCode\": 20160604, //最小版本号 \"isForced\": true, //是否强制更新,如果强制更新,需要检测最小版本号 \"downloadUrl\": \"http://www.easybui.com/download/bui.apk\", //安卓下载的地址 \"iosDownloadUrl\": \"https://itunes.apple.com/cn/app/id1362470378?mt=8\", //Appstore 地址 \"remark\": \"版本更新的内容\" //新版本的描述,支持html } 数组操作 常见的数组比对,去重,复制,过滤,移除 等. 1.5.2 以下, 第 1 个参数为要比对的值,第 2 个参数为数组. 1.5.2 以上,第 1 个参数统一为数组, 第 2 个参数为比对的值, 1.5.2 有向下兼容, 但建议全部统一数组在前. bui.array.index(arr,name,key) 返回存在的第 1 个索引,支持普通数组及 JSON 数组 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"bui\"]; var index = bui.array.index(arr, \"bui\"); // console.log(index) //结果: 1 //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, ]; var index = bui.array.index(arr, \"bui\", \"value\"); // console.log(index) //结果: 1 bui.array.indexs(arr,name,key) 返回存在的所有索引,支持普通数组及 JSON 数组 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"bui\"]; var index = bui.array.indexs(arr, \"bui\"); // console.log(index) //结果: [1,3] //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, ]; var index = bui.array.indexs(arr, \"bui\", \"value\"); // console.log(index) //结果: [1] bui.array.compare(arr,name,key) 检测是否存在 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"bui\"]; var index = bui.array.compare(arr, \"bui\"); // console.log(index) //结果: 1 //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, ]; var index = bui.array.compare(arr, \"bui\", \"value\"); // console.log(index) //结果: 1 bui.array.remove(arr,name,key) 删除数组里的某个值,返回一个新数组 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"bui\"]; var newArr = bui.array.remove(arr, \"bui\"); // console.log(newArr) //结果: [\"hello\",\"hi\"] //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, ]; var newArr = bui.array.remove(arr, \"bui\", \"value\"); // console.log(newArr) //结果: [{ \"id\":1,value:\"hello\"}] bui.array.uniq(arr,name,key) 去除重复的值 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"bui\"]; var newArr = bui.array.excess(arr, \"bui\"); // console.log(newArr) //结果: [\"hello\",\"bui\",\"hi\"] //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, { id: 3, value: \"bui\" }, ]; var newArr = bui.array.excess(arr, \"bui\", \"value\"); // console.log(newArr) //结果: [{ \"id\":1,value:\"hello\"},{ \"id\":2,value:\"bui\"}] bui.array.filter(arr,name,key) 筛选数组,可以用于搜索关键字的检测 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"easybui\"]; var newArr = bui.array.filter(arr, \"bui\"); // console.log(newArr) //结果: [\"bui\",\"easybui\"] //JSON数组: var arr = [ { id: 1, value: \"hello\" }, { id: 2, value: \"bui\" }, { id: 3, value: \"easybui\" }, ]; var newArr = bui.array.filter(arr, \"bui\", \"value\"); // console.log(newArr) //结果: [{ \"id\":2,value:\"bui\"},{ \"id\":3,value:\"easybui\"}] bui.array.copy(arr,from,length) 复制数组或某一部分, from 从第几个开始复制, 默认:0; length 不传则到数组的最后,否则以自身开始算起 例子: //普通数组: var arr = [\"hello\", \"bui\", \"hi\", \"easybui\"]; var newArr = bui.array.copy(arr, 1); var newArr2 = bui.array.copy(arr, 1, 2); // console.log(newArr) //结果: [\"bui\",\"hi\",\"easybui\"] // console.log(newArr2) //结果: [\"bui\",\"hi\"] 打电话 bui.unit.tel 例子: bui.unit.tel(\"10086\"); 发短信 bui.unit.sms 例子: bui.unit.sms(\"10086\", \"CZMM\"); 发邮件 bui.unit.mailto 例子: bui.unit.mailto({ email: \"admin@bui.com\", cc: \"test@bui.com\", subject: \"邮件主题\", body: \"邮件内容\", }); rem 转换成 px bui.unit.remToPx 例子: 按当前手机的比例转换的 rem 值 bui.unit.remToPx(\"2\"); px 转换成 rem bui.unit.pxToRem 例子: 按当前手机的比例转换的 px 值 bui.unit.pxToRem(\"200\"); 日期处理 bui 版本 1.6.0 以上 bui.date.format 日期格式化, 兼容 IOS 的日期格式转换 例子: // 时间戳转日期 var date = bui.date.format(1584781609309, \"yyyy-MM-dd hh:mm:ss\"); // 2020-03-21 17:06:49 // 日期转日期 var date = bui.date.format(\"2020-3-20\", \"MM/dd\"); // 03/20 bui.date.convert 转日期对象 例子: var date = bui.date.convert(1584781609309); date.getFullYear(); // 2020 bui.date.toWeek 某个日期为星期几, 或者周几 例子: var week = bui.date.toWeek(\"2020-3-20\"); // 星期六 var week = bui.date.toWeek(\"2020-3-20\", 1); // 周六 bui.date.after 某个日期后多少天 例子: var date = bui.date.after(\"2020-3-20\", 5); // 2020-3-25 bui.date.afterTime 某个日期后多少天 例子: var time = bui.date.afterTime(\"15:00\", 30); // 15:30 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:27:46 "},"chapter2/animate.html":{"url":"chapter2/animate.html","title":"动画交互","keywords":"","body":"动画交互 合理的使用动画让人身心愉悦, 给予用户适当的反馈,可以增强用户操作体验. 动画切换器 bui.toggle(option) 点击预览 基于animate.css的部分动画交互效果,统一了动画进场,出场的交互方式. 像 bui.dialog,bui.router 的交互都是基于 bui.toggle 实现. 参数: option 是一个对象 option.id Type: string|object Detail: 要执行动画的元素ID,或对象 option.effect Type: object Detail: 动画效果, showIn(无动画) | fadeIn | fadeInLeft | fadeInRight | fadeInDown | fadeInUp | zoomIn | bounceIn | rotateIn | flipInX | flipInY 例子: var toggle = bui.toggle({ id: \"toggle\" }); // 显示 toggle.show(); // 隐藏 toggle.hide(); 动画控制器 bui.animate(option) 点击预览 直接对元素执行transform动画 参数: option 是一个对象 option.id Type: string|object Detail: 要执行动画的元素ID,或对象 例子: 触发动画 我是动画元素 var uiAnimate = bui.animate({ id: \"#bar1\" }); $(\"#btn1\").on(\"click\", function () { uiAnimate .stop() .left(100) .start(function () { this.skewX(10).start(function () { this.left(200).start(); }); }); }); 先stop() 是为了清空之前的动画,在初始化位置位移,如果不要 stop,则是继续位移,可以一直执行 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:27:46 "},"chapter2/emitter.html":{"url":"chapter2/emitter.html","title":"发布订阅","keywords":"","body":"发布订阅 订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。 全局订阅 // dom初始化完毕就可以执行 bui.on(\"pagereadybefore\", function () {}); // 页面准备完毕后触发 bui.on(\"pageready\", function () { // 不管是web,还是native 最终都会触发 pageready 事件. }); 路由订阅 全局事件 具体查看 bui.router API // 监听后退事件,只要触发了后退, 不管通过按钮触发,还是通过物理后退 router.on(\"back\", function (e) { // 执行 // e.target 跳转后的页面 // e.prevTarget 跳转前的页面 }); // 每次跳转完成以后执行 router.on(\"complete\", function (e) { // 执行 // e.target 跳转后的页面 // e.prevTarget 跳转前的页面 }); 控件订阅 例子 1: 用得最多的 Tab 选项卡. // 初始化一个控件 var tab = bui.tab({ id: \"#id\", }); // tab有多种切换选项卡的方式, 所以只能在这里监听, 比方点击可以切换, 滑动可以切换, 直接调用to也可以触发. tab.on(\"to\", function () { var index = this.index(); console.log(index); }); // 执行就会触发一次 tab.to(0); 例子 2: // 初始化一个控件 var dialog = bui.dialog({ id: \"#id\", }); // 监听打开事件, 对话框默认是隐藏的, 隐藏的dom,在zepto.js 里面是拿不到宽高的, // 如果对话框里面有一些用到计算的地方, 应该监听该实例打开以后才做控件初始化或计算. dialog.on(\"open\", function () { // 对话框打开后才执行 }); // 监听关闭事件 dialog.on(\"close\", function () { // 对话框关闭后执行 }); 组件发布订阅 单页面上的组件通讯, 可以通过全局的 loader.on loader.trigger 等方法. 初始化 页面组件加载了搜索组件跟列表组件 搜索组件: page/search/index.js loader.define([\"page/list/index\"], function(list,require,export,module){ // 组件从上到下执行, on的监听必须在前面, 搜索组件监听了列表组件的点击事件, loader.on(\"clickid\",function(e){ // 传过来的参数 console.log(e); }) }) 列表组件: page/list/index.js loader.define(function(require,export,module){ $(\"#id\").click(function(e){ // 触发了click事件, 搜索组件那边会拿到对应的参数做相应处理. loader.trigger(\"clickid\",e); }) }) 自定义全局订阅 自定义的命名应该避免跟默认已有的冲突, 必须在trigger触发前先进行注册 // 在页面监听 bui.on(\"page-list-refresh\", function (e) { console.log(e); // 传过去的参数 }); // 在页面监听 bui.trigger(\"page-list-refresh\", \"传过去的参数\"); 例子: 假如进入列表需要权限, 进入列表就通过 bui.page 插入了一个登录页, 登录页点击校验通过就要触发关闭, 我们知道可以通过 bui.history.getPageDialog(module.id) 来获取到对话框进行关闭操作, 这种是在登录页的处理. 还有一些业务类, 之间交互比较复杂, 登录页需要不断的require之前的模块进行操作, 我们可以尝试另外一种方式. 登录只做登录该做的事. 列表页: pages/list/index.js var uipage = bui.page({ url: \"pages/login/index.html\", }); // 如果登录成功, bui.on(\"loginsuccess\", function (user) { // 关闭掉对话框 uipage.close(); // 并且在这个模块可以方便的拿到当前模块相关信息处理. }); 登录页: pages/login/index.js $(\"#login\").click(function () { // 校验帐号密码 var user = { name: \"\", password: \"\", }; // 请求去校验帐号密码, 正确就返回true if (check(user)) { bui.ajax({ url: \"http://api/login\", success: function () { // 告诉那些订阅过 loginsuccess 的操作, 可以执行了, 并把用户信息传了过去. bui.trigger(\"loginsuccess\", user); }, }); } }); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 16:25:19 "},"chapter2/extend.html":{"url":"chapter2/extend.html","title":"插件扩展","keywords":"","body":"插件扩展 以一个折叠菜单为例 控件分析 控件结构 一个点击显示隐藏的效果, 并且点击的时候, 会先把展开进行隐藏, 再展开自己的. 从界面上我们来看看结构的设计. 菜单 内容 菜单2 内容2 这里我们采用的是并列同级的方式, 那结构写起来有点麻烦, 其实这个结构跟 dl,dt,dd 是一致的, 那我们完全可以优化成以下结构. 菜单 内容 菜单2 内容2 bui的设计是基于按钮的原型撑开容器的方式, 这样可以保持每个容器都是一致的标准高度, 所以我们再对结构进行优化. 菜单 内容 菜单2 内容2 像刚刚效果图,菜单的点击还会有图标的切换, 再结合布局来得到以下结构, 一切皆布局, 一切皆容器. 菜单 内容 菜单2 内容2 控件样式 一般作为插件的独立样式引入, bui-foldmenu.css文件 .bui-foldmenu {} .bui-foldmenu>dt, .bui-foldmenu>[class*=bui-btn] { border: 0; border-bottom: 1px solid #eee; } /* 默认隐藏内容 */ .bui-foldmenu>dd { display: none; border: 0; overflow-y: auto; border-bottom: 1px solid #eee; background: #fff; } /* 图标 */ .bui-foldmenu .icon-foldmenu { -webkit-transition: -webkit-transform 0.3s ease-in-out 0s; transition: transform 0.3s ease-in-out 0s; } .bui-foldmenu .icon-foldmenu:before { content: \"\\e649\"; } /* 激活的时候显示block */ .bui-foldmenu>.active+dd { display: block; } /* 激活的二级菜单的时候,把箭头翻转 */ .bui-foldmenu>.active .icon-foldmenu { -webkit-transform: rotate(-180deg); transform: rotate(-180deg); } 样式里面就默认隐藏内容标签(dt相邻的dd),由控件初始化, 其它都是一些修饰, 设置激活状态的时候,箭头翻转. 控件脚本 1.5.4 新增 bui.extend 方法,可以用来扩展插件, 并且保持跟 bui原本的使用方式一致. bui.extend 控件参数是一个对象, 其中包含以下参数 name string 控件名称 config object 控件默认参数 callback function 控件的逻辑 最简单的版本 // 最简单的版本 bui.extend({ name: \"foldmenu\", config: { id: \"\" }, callback: function(opt) { // that 指向插件的抛出的公共方法, option widget 等 let that = this; // this.config 为已经跟初始化参数合并以后的结果; let param = this.config; // 缓存选择器 let $id = null; // 要抛给开发者的方法 that.init = function(option) { // 对直接调用init方法的参数进行合并 param = $.extend(true, {}, param, option); // 单页多页选择器,如果是单页,这个插件只能在模块里面用, 不能在bui.ready $id = bui.$(param.id); // 绑定事件,点击的时候增加激活样式 $id.children(\"dt\").click(function(e) { var hasActive = $(this).hasClass(\"active\"); if (hasActive) { $(this).removeClass(\"active\"); } else { // 加上样式以后会自动对箭头及下一层级展示处理; $(this).addClass(\"active\"); } }) return that; } // 如果有依赖bui控件,应该在这里写,这样方便外部调用 // that.widgets.loading = ui.loading({ // appendTo: opt.id // }); // 如果需要销毁的生命周期,则在这里加上. // that.beforeDestroy = function() { // // return that; // } // 必须传id if (!param.id) { // 抛出错误 bui.showLog(\"必须传id参数.\") return that; } // 默认先初始化一次 return this.init(opt); } }); 控件使用 菜单 内容 菜单2 内容2 // 初始化 var uiFloder = bui.foldmenu({id:\"#folder\"}) // uiFloder.config 可以拿到一些实例的参数 插件预览 在线预览bui.folder插件 完善插件 用闭包防止全局污染 放在一个闭包里,这样可以防止控件受到污染, window.libs 指的是 zepto 或者 jquery, 当你去掉引入 zepto.js 的时候, 引入 jquery.js 就可以完美切换成jquery版本. (jquery版本建议在: 1.9.x - 1.11.x) ;(function(ui, $) { \"use strict\"; })(window.bui || {}, window.libs); 加上注释 /* @namespace bui * @class foldmenu * @constructor * @param {object} option * @param {string} option.id [控件id] * @param {string} [option.handle] [点击的区域] * @param {number} [option.height] [父层高度,0则自适应] * @param {string} [option.target] [要显示隐藏的目标] * @param {number} [option.targetHeight] [目标自适应高度还是限制高度] * @param {boolean} [option.single] [ false(显示多个) || true(一次只折叠一个) ] * @param {function} [option.onInited] [ 1.5.1新增 初始化以后触发 ] * @param {function} [option.callback] [ 点击按钮的回调 ] * @example * */ 完整版 ;(function(ui, $) { \"use strict\"; /* @namespace bui * @class foldmenu * @constructor * @param {object} option * @param {string} option.id [控件id] * @param {string} [option.handle] [点击的区域] * @param {number} [option.height] [父层高度,0则自适应] * @param {string} [option.target] [要显示隐藏的目标] * @param {number} [option.targetHeight] [目标自适应高度还是限制高度] * @param {boolean} [option.single] [ false(显示多个) || true(一次只折叠一个) ] * @param {function} [option.onInited] [ 1.5.1新增 初始化以后触发 ] * @param {function} [option.callback] [ 点击按钮的回调 ] * @example * */ ui.extend({ name: \"foldmenu\", config: { id: \"\" }, callback: function(opt) { // that 指向插件的抛出的公共方法, option widget 等 let that = this; // this.config 为已经跟初始化参数合并以后的结果; let param = this.config; // 缓存选择器 let $id = null; // 要抛给开发者的方法 that.init = function(option) { // 对直接调用init方法的参数进行合并 param = $.extend(true, {}, param, option); // 单页多页选择器,如果是单页,这个插件只能在模块里面用, 不能在bui.ready $id = ui.$(param.id); // 绑定事件,点击的时候增加激活样式 $id.children(\"dt\").click(function(e) { var hasActive = $(this).hasClass(\"active\"); if (hasActive) { $(this).removeClass(\"active\"); } else { // 加上样式以后会自动对箭头及下一层级展示处理; $(this).addClass(\"active\"); } }) return that; } // 如果有依赖bui控件,应该在这里写,这样方便外部调用 // that.widgets.loading = ui.loading({ // appendTo: opt.id // }); // 如果需要销毁的生命周期,则在这里加上. // that.beforeDestroy = function() { // // return that; // } // 必须传id if (!param.id) { // 抛出错误 ui.showLog(\"必须传id参数.\") return that; } // 默认先初始化一次 return this.init(opt); } }); })(window.bui || {}, window.libs); 结语 上面我们示例了一个最简单的插件的开发及使用, 但插件的适应性还不够, 还需要考虑各种扩展性,复杂的场景如何去适应, 比方内容是需要固定高度,选择器换成其它,只展示一个,等各种需求都不能满足, 我们需要考虑更多的场景, 抽取更多的变量作为可配置. Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-01-06 11:38:45 "},"chapter2/import.html":{"url":"chapter2/import.html","title":"第三方插件","keywords":"","body":"第三方插件 1. 全局引入 插件必须放在 src/js/plugins/ 目录下，插件才不会被 2 次编译。 src/index.html 2. 按需动态引入 在需要引入的地方，通过 loader.import 动态引入 loader.define(function (requires, exports, module, global) { // 例如：异步导入 loader.import( [\"js/plugins/echarts/echarts.css\", \"js/plugins/echarts/echarts.js\"], function () { // 回调里才能拿到 echarts全局变量 echarts.init(); } ); }); 有些插件，例如高德地图，只支持全局引入。 3. 导入 NPM 模块 1.7.0 以上支持引入 NPM 模块，且默认工程已经加入 vconsole 模块，如果没有，请先执行以下命令。导入的 npm 模块最终是静态编译在脚本中。 执行安装模块命令 # 进入工程 cd bui-demo # 安装模块 npm i vconsole --save 在需要的地方导入模块 src/index.js // 导入手机调试模块 import VConsole from \"vconsole\"; // 初始化手机调试 const vConsole = new VConsole(); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:27:24 "},"store/about.html":{"url":"store/about.html","title":"介绍","keywords":"","body":"介绍 我们按照 vue 的接口设计了一个基于真实 Dom 的数据驱动方式，可以实现一些简单的操作，如果你熟悉 vue，很容易上手。 注意: 使用 bui.store 意味着放弃安卓低版本的兼容, 比方安卓 4.3 的浏览器对这种数据解析方式支持不太好, 打包影响不大, 取决于打包的内核. 查看示例 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/distance.html":{"url":"store/distance.html","title":"store 实例","keywords":"","body":"实例 1. 创建一个store实例. el 挂载的根元素, 默认是: .bui-page scope 数据的范围, 必须字段, 比方公共数据可以使用app, 页面里面的数据默认使用 page，组件应该更改为组件相关的名字 isPublic 是否是公共数据, 默认: false | true data 数据的定义, 结合行为属性使用 watch 侦听器, 侦听 data 里面的字段改变, 触发当前回调 computed 计算属性, 结合 data 的字段的处理, 比方加减乘除 methods 自定义的方法, 通过行为属性b-click访问 templates 模板的定义,通过行为属性b-template访问 beforeMount 数据解析前执行 mounted 数据解析后执行 bui.store初始化, 单页一般在loader.define 里面, 多页在 bui.ready 里面. loader.define(function () { var bs = bui.store({ el: \".bui-page\", scope: \"page\", data: {}, methods: {}, watch: {}, computed: {}, templates: {}, beforeMount: function () { // 数据解析前执行 }, mounted: function () { // 数据解析后执行 }, }); }); 2. 基本使用 实例的名字使用bs (behavior store)作为实例名. b 标签作为这个数据关联的默认标签. var bs = bui.store({ scope: \"page\", data: { size: 1, }, }); // 设置以后就会触发dom b-text=\"page.size\"的视图更新 bs.size = 2; 当这些数据改变时，视图会进行重渲染。绑定到模板里面的写法是 page.xxx 而不是 bs.xxx . 注意: 新增的属性不是响应式的. 例如: bs.number = 12; 在进行视图的设计的时候, 需要对这些值进行初始值的设定, 自定义键值, 比如: data : { str: '', num: 0, bool: false, lists: [], } 3. 加载的时机 当 store 初始化的时候, 会做两件事情 第 1 件事, 把当前已有的数据进行代理, 也就是 vue 使用的 Object.define来处理 data,watch,computed 这些数据挂载到 store 实例本身; 第 2 件事, 把模板进行匹配过滤, 找到对应的选择器. 在这两件事前后, 会分别执行beforeMount, mounted 方法. 所以一般业务都应该在 mounted 里面执行. 4. 动态加载时机 我们看到上面的数据都是静态数据, 一开始数据是有初始值的, 但有时候我们还有动态数据, 需要通过请求以后才能加载进来, 这种又该如何处理呢? var bs = bui.store({ scope: \"page\", data: { list: [], }, templates: { tplList: function (data) { var html = \"\"; data.forEach(function (item, i) { html += `${item}`; }); return html; }, }, mounted: function () { // 模拟数据动态改变 setTimeout(() => { // 方法1: // this.list.push(\"广州\",\"深圳\",\"上海\",\"北京\"); // 方法2: 合并并触发 this.list 的视图更新 // bui.array.merge(this.list,[\"广州\",\"深圳\",\"上海\",\"北京\"]) // 1.7.x this.list = [\"广州\", \"深圳\", \"上海\", \"北京\"]; }, 1000); }, }); 5. 公共数据与私有数据 通过scope来区分数据源, 再加上isPublic:true这个参数, 在index.js初始化以后, 所有的单页页面都可以拿到这个公共数据, 当公共数据改变的时候, 多个页面的数据视图都会重新渲染. window.router = bui.router(); bui.ready(function () { // 公共数据 window.store = bui.store({ scope: \"app\", isPublic: true, data: { firstName: \"Hello\", lastName: \"BUI\", }, }); // 初始化路由 router.init({ id: \"#bui-router\", progress: true, hash: true, store: store, }); }); 如上面例子: store.firstName=\"Bingo\" 的时候, 所有单页页面上有 进行渲染的模板,都会一起改变. Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/computed.html":{"url":"store/computed.html","title":"计算属性与侦听器","keywords":"","body":"计算属性与侦听器 1. computed 选项 模板不支持表达式, 模板尽量精简, 把表达式定义到 computed 里面, 可以处理跟data相关的计算. 例子 1: 点击按钮的时候,a更新,并触发页面上的 aDouble 的 dom 更新. js: var bs = bui.store({ scope: \"page\", // 用于区分公共数据及当前数据的唯一值 data: { a: 2, }, methods: { changeA: function (e) { this.a++; }, }, computed: { aDouble: function () { // a 改变的时候,会触发乘法,并更新到dom return this.a * 2; }, }, }); html: 点击1次,a+1,结果乘以2 a: 结果: 例子 2: 通过b-model把firstName,lastName 渲染出来, 并且当 input 输入修改的时候,会触发fullName的修改. fullName 支持两种方式设置. function object 区别: function方式,fullName 的修改不会重新赋值到 firstName, lastName. 如果要实现双向联动绑定, 则采用object方式, 以对象的方式. 查看例子 3. js: var bs = bui.store({ scope: \"page\", // 用于区分公共数据及当前数据的唯一值 data: { firstName: \"Hello\", lastName: \"BUI\", }, computed: { fullName: function () { var val = this.firstName + \" \" + this.lastName; return val; }, }, }); html: 姓: 名: 结果: 例子 3: 双向联动修改, bs.fullName = \"BUI Best\" 设置以后, 会把firstName,lastName 重新赋值. js: var bs = bui.store({ scope: \"page\", // 用于区分公共数据及当前数据的唯一值 data: { firstName: \"Hello\", lastName: \"BUI\", }, computed: { // 2. 双向联动 fullName 改变,会触发各自改变 firstName,lastName, fullName: { get: function () { return this.firstName + \" \" + this.lastName; }, set: function (newValue) { var names = newValue.split(\" \"); this.firstName = names[0]; this.lastName = names[names.length - 1]; }, }, }, }); 例子 4: 登录按钮的状态, 当firstName,lastName 有值的时候, 登录按钮可以点击; disabled 状态为 false, 当没有值的时候, disabled 为 true 不能点击.disabled computed 绑定在登录按钮的b-class上, 有值没值的时候, 会去修改 class 有没有 disabled 样式名. js: var bs = bui.store({ scope: \"page\", // 用于区分公共数据及当前数据的唯一值 data: { firstName: \"\", lastName: \"\", }, computed: { disabled: function () { // 注意: 这里需要先缓存下来值再进行判断. var firstName = this.firstName, lastName = this.lastName; if (firstName && lastName) { return false; } else { return true; } }, }, }); html: 姓: 名: 登录 注意: disabled方法里面, 有个注释提醒, 为何要先缓存? 因为经常我们习惯性的直接去判断? 比如: if (this.firstName && this.lastName) { return false; } else { return true; } 当初始值 firstName跟lastName 为空的时候, if 只拿到 firstName 不正确, 就会跳到 true, 导致 lastName 改变的时候,不会重新执行判断条件. 这在computed是经常见到的错误, 如果你希望这些值都会改变 disabled, 那应该先进行缓存. 效果预览 查看效果 2. watch 选项 watch 可以用来监听 data 里面的键值的变化以后处理其它事情. watch函数返回当前监听变量的新值跟旧值newVal,oldVal. 比方下面的例子. 例子 4: var bs = bui.store({ scope: \"page\", // 用于区分公共数据及当前数据的唯一值 data: { a: 2, b: 1, }, methods: { changeA: function (e) { this.a++; }, }, watch: { a: function (newVal, oldVal) { this.b = this.a * 2; }, }, }); html: 点击1次,a+1,结果乘以2 a: 结果: computed 的例子也可以用watch实现. var bs = bui.store({ scope: \"page\", data: { firstName: \"Hello\", lastName: \"BUI\", fullName: \"Hello BUI\", }, watch: { firstName: function (val) { this.fullName = val + \" \" + this.lastName; }, lastName: function (val) { this.fullName = this.firstName + \" \" + val; }, }, }); 除了 watch 选项之外，您还可以使用命令式的 bs.watch 方法。可以实现分离式监听. bs.watch(\"firstName\",function(val){ this.fullName = val + ' ' + this.lastName }) bs.watch(\"lastName\",function(val){ this.fullName = this.firstName + ' ' + val }) 效果预览 查看效果 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/template-synatax.html":{"url":"store/template-synatax.html","title":"模板语法","keywords":"","body":"模板语法 数据改变的时候应该做什么事情, 这是通过行为属性去绑定的. 行为属性语法 属性名 语法示例 语法描述 b-text 设置文本,一般使用 b 标签 b-html 设置 html,html 一般使用 div 标签 b-value 设置 value, b-value 属性,必须是 input 标签 b-show 显示当前 dom, page.isShow=false; 则控制不显示. 初始化的时候是隐藏,则设置 b-model 双向绑定,会把当前值,设置到 value 属性,并监听 value 的改变,改变又会重新设置 page.size 的值 b-bind 设置属性, key 值为属性名, 结果: b-style 设置 style 的样式, key 值为样式属性, 结果: b-class 设置 class 的样式, 结果: , classNames 可以是对象,也可以是字符串,或者是布尔值 b-template 绑定模板,page.list 的数据更新会及时反应到页面上 b-command 非必须,配合 b-template 一起使用,代表第一次模板渲染采用什么方法, 默认是 html, append, prepend b-children 非必须,配合 b-template 一起使用, 代表子集的元素,当子集里面有其它布局元素干扰的时候,才做配置, 可以是标签,类名 b-click 点击事件, openDialog 在 methods 定义. b-target 1.5.2 新增 可以控制当前 this 的指向,这样会影响到 $index $this 等内置值,会在当前往上查找 b-target. 一般用于嵌套的层级过深,找不到父级 index 使用 b-src 1.5.2 新增 动态图片地址 b-href 1.5.2 新增 动态跳转地址 b-placeholder 1.7.0 新增 占位文本 b-title 1.7.0 新增 标题属性 b-model-lazy 1.7.0 新增 blur 失去焦点的时候才会设置值 b-trigger 1.7.0 新增 实时修改的时候触发某个方法 b-data-xxx 1.8.5 新增 自定义属性，相当于 data-title=\"value\" b-bind-title 1.8.5 新增, 增加 b-bind 的灵活性 b-color,b-width,b-height,b-background,b-border 1.8.5 新增, 增加 b-style 的灵活性, 相当于 style=\"color:xxx\" b-cloak 1.8.5 优化，渲染完才会展示 b-if，b-else-if, b-else adminmanagerguest 1.9.0 新增 b-if 判断类的处理, b-else-if, b-else 必须跟 b-if 同级 b-switch, b-case, b-default adminmanagerguest 1.9.0 新增 b-switch 判断类的处理 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2023-11-23 13:55:44 "},"store/attribute.html":{"url":"store/attribute.html","title":"属性与值绑定","keywords":"","body":"属性与值绑定 1. 属性动态绑定 b-bind 绑定支持 2 种数据格式. 并且通过 bs.title=\"XXX\" 或者 bs.attrs.title=\"xxx\" 可以触发属性的修改. 绑定的字段在 data 里面 Object : 键值为样式名,值为布尔值 String : 值为样式名 var bs = bui.store({ scope: \"page\", data: { title: \"这是动态标题\", attrs: { title: \"这是动态标题\", \"data-title\": \"自定义标题\", }, }, }); html: 绑定title属性,及自定义属性 绑定title属性 效果预览 查看效果 2. 值的动态绑定 有三种值的设置, 推荐 b 标签作为默认的双向绑定标签. 如果内容元素是块状, 可使用 div 标签. b-text : 设置文本 b-html : 设置 html b-value : 设置属性 value,一般用于表单 var bs = bui.store({ scope: \"page\", data: { value: \"Hello bui.js\", attrs: { title: \"这是动态标题\", }, title: \"html标题\", }, }); 效果预览 查看效果 3. 静态解析 静态解析里面的值. 默认没有开启, 如果需要, 初始化时设置 `needStatic: true` 才会解析. `templates`定义的模板方法里面不要使用 或者 b-开头的模板命令. 不支持表达式 不支持动态修改 只在第一次渲染解析 var bs = bui.store({ scope: \"page\", data: { title: \"这是动态标题2\", attrs: { title: \"这是动态标题\", \"data-title\": \"自定义标题\", }, }, needStatic: true, }); html: {{page.title}} Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/class.html":{"url":"store/class.html","title":"class 与 style 绑定","keywords":"","body":"Class 与 Style 的绑定 1. Class 绑定 b-class 绑定支持 4 种数据格式. Object : 键值为样式名,值为布尔值 Array : 值为样式名, 会删除默认的 class 样式 Boolean : 键值为样式名,值为布尔值 String : 值为样式名 var bs = bui.store({ scope: \"page\", data: { active: true, activeClass: \"active\", tabClass: { active: true, hasActive: true, }, tabClassNames: [\"tab\", \"active\"], }, }); html: tabClass是一个对象,键值为样式名 tabClassNames是数组,键值为样式名 active 是一个布尔值 activeClass 是一个字符串 2. Style 绑定 b-style 绑定支持 2 种数据格式.当绑定的是一个对象时, 可以绑定多个, key 值为 css 的键值, 比方color,display,background,等. 以下例子, page.styles.color=\"green\" 或 page.color = \"red\" 都会触发该元素的颜色变更. Object : 键值为样式名,值为布尔值 String : 值为样式名 var bs = bui.store({ scope: \"page\", data: { styles: { color: \"red\", }, color: \"green\", }, }); html: 绑定title属性,查看源码才能看到 绑定title属性,查看源码才能看到 效果预览: 查看效果 3. 显示与隐藏 b-show 可以根据数据的状态来控制当前元素的显示或者隐藏. b-model 是双向绑定的内容,可以查看表单绑定的章节. var bs = bui.store({ scope: \"page\", data: { show: true, }, }); 我是A,被控制的内容 我是B,跟A相反的状态 点击可以控制A和B: 效果预览: 查看效果 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:11 "},"store/template.html":{"url":"store/template.html","title":"模板渲染","keywords":"","body":"模板渲染 1. ES6 模板 b-template 的值的字段在 templates 里面定义. 注意: 子集的内容必须有标签包住. 例如模板里面的li标签. 数据支持数组 var bs = bui.store({ el: \".bui-list\", scope: \"page\", data: { list: [\"我是列表1\", \"我是列表2\"], }, templates: { tplList: function (data) { let html = \"\"; data.forEach(function (item, i) { html += `${item}`; }); return html; }, }, }); 数据支持对象 var bs = bui.store({ scope: \"page\", data: { obj: { title: \"我的对象的标题\", content: \"我是内容,支持html我是内容,支持html\", }, }, templates: { tplObject: function (data) { let html = \"\"; for (let key in data) { html += `${data[key]}`; } return html; }, }, }); 层级对象 var bs = bui.store({ el: \".wrap\", scope: \"page\", data: { objList: { title: \"我是标题\", data: [\"我是复杂数据列表1\"], }, }, templates: { tplObjectList: function (data, e) { var html = \"\"; data.forEach(function (item, i) { html += `${item}`; }); return html; }, }, }); 如果 h2 是在 ul 里面, 那么默认第一次渲染数据, h2 就会被替换, 这时可以通过 b-command 属性,告诉模板第一次渲染采用什么方式. :) 当然这里ul标签里面放h2标签是不符合 w3c 标准的. 我们改成li标签. html 替换模板 append 在模板后面增加 prepend 在模板前面增加 数据的增删改 通过b-template的绑定, 我们可以通过操作数组,便能得到页面的及时响应. var bs = bui.store({ el: \".bui-list\", scope: \"page\", data: { list: [\"我是列表1\", \"我是列表2\"], }, templates: { tplList: function (data) { let html = \"\"; data.forEach(function (item, i) { html += `${item}`; }); return html; }, }, }); 通过脚本操控 bs.list.push(\"我是列表3\") , 页面便能及时渲染新的数据. 并非数组的所有操作都能得到及时响应, 可以监听到以下几种方法: push 在后面增加数据 unshift 在前面增加数据 shift 删除第 1 条数据 pop 删除最后一条数据 splice 删除或者插入新的数据, 具体可以查看数组的 splice 用法 sort 排序 reverse 反序 length 获取长度 为了更方便的操作数据视图, 我们还提供了几个命令式的方法, 可以方便的对数组进行操作响应. 具体可以查看对应的 bui.array API 使用说明, 在综合案例里面, 我们会频繁的用到. bui.array.empty 清空数组,并触发第 1 个数组的视图变更 bui.array.replace 替换数组,并触发第 1 个数组的视图变更 bui.array.merge 合并数组,并触发第 1 个数组的视图变更 bui.array.set 修改数组的某个值,支持对象 bui.array.delete 删除数组的某个值,支持对象 模板的交互 当前选中: var bs = bui.store({ el: \".wrap\", scope: \"page\", data: { citysCheck: [\"广州\", \"深圳\"], citys: [\"广州\", \"深圳\", \"上海\", \"北京\"], }, templates: { tplListCheck: function (data) { var html = \"\"; data.forEach(function (item, i) { html += `${item}`; }); return html; }, }, }); 效果预览 查看效果 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/if.html":{"url":"store/if.html","title":"if与switch判断","keywords":"","body":"if与switch判断 1.9.0 新增 if 判断 b-if 可以单独使用，b-eles-if, b-else 不能，且必须跟 b-if 在同一层级。 admin admin manager vip guest admin guest loader.define(function(require,exports,module,global){ var bs = bui.store({ data: { role:\"admin\" } }) return bs; }) 具体示例查看：demo switch 判断 b-switch 与 b-case, b-default 都不能单独使用，跟if的区别，在于结构是包含关系。 admin manager vip guest loader.define(function(require,exports,module,global){ var bs = bui.store({ data: { role:\"admin\" } }) return bs; }) 具体示例查看：demo Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2024-05-01 10:38:32 "},"store/form.html":{"url":"store/form.html","title":"表单绑定","keywords":"","body":"表单绑定 1. 双向绑定 注意: input 的 type 类型必须声明是哪种类型(text,radio,checkbox)等. 示例: page.message 有 3 个地方用到, b-model, b-text, b-click点击的时候,也会拿到message去做处理. var bs = bui.store({ scope: \"page\", data: { message: \"Hello bui.js\", }, methods: { reverseMessage: function (e) { var a = this.message.split(\" \").reverse().join(\" \"); this.message = a; }, }, }); 正在输入: 反序输入值 效果预览 查看效果 b-model 的值支持 3 种数据类型 字符串: 用于单选或输入 布尔值: 用于多选 数组: 用于多选 2. 单选双向 page.sex 的值是string, 会先设置回对应的value=\"女\"的 input, name 的值的 sex1 不是必须的, 这个是 h5 用来对选择进行分组的. b-text 用来输出当前的选中值. var bs = bui.store({ scope: \"page\", data: { sex: \"女\", }, }); 男 女 性别: 3. 多选双向 多选是一个数组, 里面的值会跟自己本身的值进行比较,如果一致,会是选中状态. b-text 输出数组会加上逗号. var bs = bui.store({ scope: \"page\", data: { citys: [\"广州\", \"深圳\"], }, }); 广州 汕头 深圳 东莞 多选: 城市: 4. 状态联动 当b-model的值是布尔值时, 加上b-show 可以根据数据的状态来控制当前元素的显示或者隐藏. var bs = bui.store({ scope: \"page\", data: { show: true, }, }); 我是A,被控制的内容 我是B,跟A相反的状态 点击可以控制A和B: 效果预览 查看效果 5. 选择列表 下面只是展示 select 的用法, 实际上移动端我们一般使用 bui.select控件. 单选 var bs = bui.store({ scope: \"page\", data: { selected: \"B\", // 单个select初始化的值 options: [ // 单选多选的数据源 { text: \"One\", value: \"A\" }, { text: \"Two\", value: \"B\" }, { text: \"Three\", value: \"C\" }, ], }, templates: { tplSelect: function (data) { var html = \"\"; data.forEach(function (item, i) { // value 属性必须有 html += `${item.text}`; }); return html; }, }, }); Selected: 多选 只是把选择项变成了数组, 把select加多了个属性 multiple. var bs = bui.store({ scope: \"page data: { multipleSelectes: [\"A\",\"B\"], // 多选select初始化的值是一个数组 options: [ // 单选多选的数据源 { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] }, templates: { // 单选多选共用模板 tplSelect: function (data) { var html =''; data.forEach(function (item,i) { // value 属性必须有 html +=`${item.text}` }) return html; } } }) 请选择 Selected: 这里会有个 b-command 属性,用来告诉模板第 1 次渲染的时候使用什么方法? html 替换数据 append 在后面增加数据 prepend 在前面增加数据 单选联动 联动的示例,增加了事件绑定, $index是内置对象,代表点击当前 dom 的索引, 有意思的是, 这里为什么是 $index 而不是 i ? i 是每次都从 0 开始的, 当数据有增删改以后, 索引值是不确定的, 而 $index 是根据你当前的 dom 所在的索引, 这个跟数组的索引是一一对应的. 更多内置对象,请查看事件绑定章节. var bs = bui.store({ scope: \"page\", data: { selectA: [ // 联动select的数据源 { text: \"One\", value: \"A\" }, { text: \"Two\", value: \"B\" }, { text: \"Three\", value: \"C\" }, ], selectB: [], }, methods: { addToB: function (index) { this.selectB.push(this.selectA[index]); this.selectA.splice(index, 1); }, addToA: function (index) { this.selectA.push(this.selectB[index]); this.selectB.splice(index, 1); }, }, templates: { tplSelectA: function (data) { var html = \"\"; data.forEach(function (item, i) { // value 属性必须有 html += `${item.text}`; }); return html; }, tplSelectB: function (data) { var html = \"\"; data.forEach(function (item, i) { html += `${item.text}`; }); return html; }, }, }); 效果预览 查看效果 多选联动 这个例子是一个自定义的模拟 select, 我们放在综合案例里面讲. 弹窗选择交互 5.动态表单 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:11 "},"store/event.html":{"url":"store/event.html","title":"事件处理","keywords":"","body":"事件处理 1. 基本使用 b-click 的值的字段在 methods里定义. 在方法里面,可以通过event拿到点击的上下文关系. 最简单 var bs = bui.store({ scope: \"page\", methods: { getMessage: function (e) { console.log(e); }, }, }); 2. 事件传参 常规参数 示例: 点击输出3个参数:3,[4],{\"test\":\"对象\"} var bs = bui.store({ scope: \"page\", methods: { getMessage: function (a, b) { console.log(a); // 输出3 console.log(b); // 输出4 }, }, }); 如果参数是对象,需要是一个标准 JSON 才能转换, b-click 属性值并且一定要用单引号''. 另外传参里面不能有(),& 之类的特殊字符,会导致解析出错或者数据出错, 可以看复杂参数的处理. 复杂参数 示例: var bs = bui.store({ scope: \"page\", methods: { getMessage: function (dom) { // 这个名字太复杂只能通过属性的方式获取, 或者传索引跟数据匹配的方式 var name = $(dom).attr(\"name\"); }, }, }); 点击输出3个参数:3,[4],{\"test\":\"对象\"} 示例 2: 通过索引来取这个数据 通过索引来取这个数据 var bs = bui.store({ scope: \"page\", data: { datas: [ { id: \"1\", name: \"test1\" }, { id: \"2\", name: \"test2\" }, ], }, methods: { getMessage: function (index) { // 这个名字太复杂只能通过属性的方式获取, 或者传索引跟数据匹配的方式 console.log(this.$data.datas[index]); }, }, }); $index 是动态索引, 代表点击的元素 li 在第几个索引, 跟你渲染的数据是一一对应的. 类似的还有 $parentIndex 内置参数 有些时候,我们不得不通过 dom 去操作的时候, 可以通过一些内置的参数传给方法. $itemIndex: 模板子集的索引，跟数组是一一对应关系 $index: 当前索引 $parentIndex: 父层索引,只能取一层 $text: 当前元素的文本 $html: 当前的内容包含 html $this: 点击本身的 dom $parent: 父层的 dom $children: 子集的$dom 示例: var bs = bui.store({ scope: \"page\", methods: { getMessage: function (a, b) { console.log(a); // 当前索引 console.log(b); // 当前的dom对象 }, remove: function (index) { console.log(index); // 拿到跟 a 一样的索引. }, }, }); 删除 示例里面的remove方法, 如果传的是 $index, 那它永远等于 0, 而$parentIndex 是会根据父级的元素改变的. 如果层级太深, 通过$parentIndex 都不能获取到, 那b-target属性就可以派上用场了 例如: 标题名 删除 删除 3. 自定义事件传参 示例: var bs = bui.store({ scope: \"page\", methods: { getMessage: function (index) { // 触发自定义事件,参数可以自定义 this.trigger(\"remove\", \"自定义参数\"); }, }, mounted: function () { // 加载后, 监听自定义remove的时候做什么事情. this.on(\"remove\", function (a) { console.log(a); }); }, }); 4. 事件与数据联动 通过点击触发 a 值的改变, 在 a 值改变的时候, 又可以处理不同的事情. 示例: var bs = bui.store({ scope: \"page\", data: { a: 1, }, methods: { changeA: function () { this.a++; }, }, watch: { a: function (newVal, oldVal) { console.log(newVal); // 改变后的值 console.log(oldVal); // 改变前的值 }, }, }); 改变a的值,触发watch事件 效果预览 查看效果 点击的时候,查看 chrome 控制面板的输出信息. Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/mixins.html":{"url":"store/mixins.html","title":"混入","keywords":"","body":"混入 实例分发 混入minxins参数 提供了一种灵活的方式, 把bui.store的实例进行划分. 它是一个数组, 数组里面每个对象包含bui.store的选项, 实例自身的属性会覆盖mixins的相同属性. pages/main/main.js var bs = bui.store({ id: \".bui-page\", scope: \"page\", mixins: [ { data: { title: \"标题2\", }, methods: {}, watch: {}, computed: {}, beforeMount: function () { // console.log(this.$data.title) }, mounted: function () { console.log(this.$data.title); }, }, ], data: { title: \"标题\", }, methods: {}, watch: {}, computed: {}, beforeMount: function () { // console.log(this.$data.title) }, mounted: function () { console.log(this.$data.title); // 标题 }, }); 改写为 pages/main/main.js loader.define([\"pages/list/index\"]function(list,require,export,module){ var bs = bui.store({ id: \".bui-page\", scope:\"page\", mixins: [list], data: { title:\"标题\" }, methods: {}, watch: {}, computed: {}, beforeMount:function(){ // console.log(this.$data.title) }, mounted:function(){ console.log(this.$data.title) // 标题 }, }) }) 定义列表模块 pages/list/index.js loader.define(function(require,export,module){ var data = { data: { title:\"标题2\" }, methods: {}, watch: {}, computed: {}, beforeMount:function(){ // console.log(this.$data.title) }, mounted:function(){ console.log(this.$data.title) } } // 抛出对象 return data; }) 通过view标签把模板分发. pages/main/main.html 通过分发出去的 view 组件, 最终是合并在一个实例上, 模块之间会按先后顺序覆盖, 没有独立的作用域. 独立作用域 需要独立作用域时, 应该使用的是 component标签. 模块里面需要返回一个实例, 而不是普通对象. pages/list/index.html pages/list/index.js loader.define(function(require,export,module){ // module.id = list var bs = bui.store({ el: `#{module.id}`, scope: \"list\", data: { title:\"标题\" }, mounted: function(){ console.log(\"list 模块已经加载\") } }) return bs; }) 案例 在一个模块里面处理三个 Tab 不好维护, 可以把每个 tab 的内容进行分发. 这是一个bui.floor跟 bui.store结合的例子. 其中用到了延迟加载, 滚动到第 2 个的时候, 会自动加载第 3 个模板, 加载了模板以后, 还需要通过实例的 bs.$mount方法, 重新编译该组件的数据. Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"store/component.html":{"url":"store/component.html","title":"组件化","keywords":"","body":"组件化 组件的按钮例子改为store版本 按钮 loader.define(function(requires,exports,module,global){ // 接收外部参数 let props = module.props; var bs = bui.store({ el: `#${module.id}`, scope: 'btn', data: { text: props.text || \"\", color: props.color || \"\", }, mounted(){ // 加载完成后初始化 }, methods: { submit(e){ bui.alert(\"绑定点击事件\") } } }) return bs; }) 使用 Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-01-06 16:26:56 "},"store/debug.html":{"url":"store/debug.html","title":"数据调试","keywords":"","body":"数据调试 如果把里面的变量bs,改成 window.bs, 可以在控制面板里面调试数据, window.bs.list.push(\"我是列表3\") 所有模板都会增加数据. 调试结束记得更改回局部变量 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-01-06 15:13:11 "},"store/case.html":{"url":"store/case.html","title":"综合案例","keywords":"","body":"综合案例 1. 待办处理 预览 查看效果 2. 弹窗选择交互 如果数据一开始有值,还需要把值跟模板里的数据进行比对,处理成选中状态. 预览 查看效果 3. 多选联动复杂场景 预览 查看效果 2.2 代码优化版 预览 查看效果 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-07-08 10:24:10 "},"help.html":{"url":"help.html","title":"常见问题","keywords":"","body":"帮助中心 前言 新手使用 BUI 开发中常见的问题, 如果这里找不到你的答案, 可以像我们提问, 问题中尽量描述清楚你要实现的功能及效果, 我们会尽快答复. 我要提问 数据问题 Q: 接口请求如何跨域? 答: 调试 该问题在调试一节已经给出方案. 功能问题 Q: 代码已经写在 bui.ready 里面,为何调试不了原生功能? webapp版本不用了解. 答: 1. 设置 bui.isWebapp= false; 2. 确认你的 bui.js 是带原生功能版本; 输出 console.log(bui.currentPlatform). 3. 你的方法都在 bui.ready 里面 Q: BUI 为什么需要计算 main 的高度? 答: 上中下是移动端常见的一种结构,当然实现这种布局的方式有很多, 比如, 第1种, 你可以使用绝对定位或者固定定位的方式, 固定定位以后,中间的内容的坐标就变成0; 我们可以给中间内容加上padding的方式. 这样当头部变高或者不要头部的时候, 或者ios 在viewport下不支持fixed的情况, 这种方式带来的弊端就比较明显了.这也是BT最早的UI采用的方式,最终还是得通过计算的方式. 第2种, 自从有了css3以后,我们有flex布局可以实现对页面的垂直布局有了很好的支持,我可以头部固定,底部固定,中间自适应, 可惜的是这种布局在移动终端的适应性有局限性, 低配的手机都不支持,就连微信都不支持. 第3种, 也就是我们采用的计算的方式,在页面初始化前先进行计算,固定好他们各自该在的位置.你中间的内容也就能够自适应,它没有第1种的ios兼容问题,用户也不用去管用不用设置padding, 也没有第2种的兼容问题.他只提供一个框架上的容器,你不需要的时候就删除对应的标签即可. 虽然需要动态计算耗一点性能,但这个对于页面初始化之前丝毫没有影响.另外它还可以解决,当页面跳转导致的webview高度问题. 当然,你如果不喜欢这种计算的方式,你也可以使用自己认为合适的方式,不使用 bui-page header main footer 这几个保留样式名就行. Q: iconfont 图标冲突问题 答: 引入第三方 iconfont 以后,里面的字体图标不能以 .icon- 命名, 需要全局修改. 默认bui使用的字体图标名字为: font-family:\"icon\"; 并且所有 .icon 或 .icon- 会自动引用默认字体图标的样式, 如果要自定义一个图标, 可以以 icons- 开头,避免冲突. 尽量使用默认图标, 点击查看所有图标 使用 unicode 编码图标示例: &#xe60a; 自定义样式名 &#xe658; Q: 如何打电话,发短信,发邮件? 答: 打电话; bui.unit.tel(\"10086\"); 发送短信; bui.unit.sms(\"10086\", \"CZMM\"); 发邮件; bui.unit.mailto({ email: \"bui@easybui.com\", cc: \"抄送\", subject: \"邮件标题\", body: \"邮件内容\", }); 方案 2: 可以保持跟 a 标签调用的方式一致, 前提是当前按钮已经绑定静态跳转 打电话 Q: 微信调试缓存问题? 答: 多页开发需要手动修改js的引用加入时间戳 单页开发只要在index.js, 重新初始化 window.loader, 动态加载的模块就会自动加上时间戳, 这句需要在 `window.router = bui.router()` 初始化之前 window.loader = bui.loader({ cache: false }) Q: 应该使用 tap 事件还是 click 事件? 答: bui的开发推荐全部使用click事件, tap事件在移动端会存在一些兼容问题. Q: input 被输入法遮挡问题? 答: 方案1: 输入框在底部用方案1; $(\".bui-input\").on(\"click\", function () { // 使用定时器是为了延迟计算 setTimeout(function () { bui.init({ id: router.$(\".bui-page\"), }); router.$(\".bui-page\")[0].scrollIntoView(); }, 300); }); // 指定某个input,避免每次都要重复计算 $(\"input\").on(\"blur\", function () { // 使用定时器是为了延迟计算 setTimeout(function () { bui.init({ id: router.$(\".bui-page\"), }); router.$(\".bui-page\")[0].scrollIntoView(); }, 300); }); 方案2: 顶部会看不到; $(\".bui-input\").on(\"click\", function () { $(\"html,body\").css(\"overflow\", \"scroll\"); var target = this; // 使用定时器是为了缓冲 setTimeout(function () { target.scrollIntoView(true); }, 100); }); 单页开发问题 B 页面跟 D 页面,都跳转到 C 页面, 那 C 页面如何能够确保后退到 B 页面? ?> 路由 1: A->b>-C , 路由 2: A>B>D>C 答: 指定后退到B模块, B模块如果不是自定义名称, 则输入B页面的路径名,无后缀. router.back({ name: \"B\" }) Q: 如何跳转锚点? ?> 单页里面的锚点已经更改成模块加载, 锚点跳转是禁止的.可以利用 scrollTop = 某个高度来实现, 首先你需要知道你当前的滚动条是在哪里? 正常滚动条是在main标签, tab 控件的滚动是在 .bui-tab-main > ul > li 层. list 控件的滚动条则在 bui-scroll 答: 以main标签为例. 锚点跳转 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 我在这里 // 返回顶部 document.querySelector(\".main-scroll\").scrollTop = 0; // 跳转指定id var jumpTop = document.querySelector(\"#jump\").offsetTop; document.querySelector(\".main-scroll\").scrollTop = jumpTop; Q: 是否可以在单页的.html页面直接引入样式,脚本及初始化 ?> 可以,但是要注意的是, 样式会影响全局, 脚本引入跟初始化不会被缓存, 每次都是新的, 也无法抛出共享给其它页面调用. 答: 我们更推荐使用同名的 js,在 define 里面初始化. loader.define(function () { // 在这里初始化你的脚本 }); Q: a 标签跳转跟 bui.load 的区别? 答: 当 bui.isWebapp=true; 的时候,其实是一样的, 但使用 bui.load 会多一种可能性, 可以随状态变成原生跳转. 而当绑定按钮及A标签的静态跳转以后, bui.btn({id:\".bui-page\",handle:\".bui-btn,a\"}).load(); a标签跳转 = bui.load 跳转. 需要注意的是 a 标签默认点击会受样式的伪类状态影响, 默认我们使用 div 标签模拟. Q: 页面跳转的静态属性传参? 答: 静态传过去的参数必须是一个标准的 json 字符 html += \"跳转传参示例\"; 控件问题 Q: 如何全局修改请求? ?> 正常我们开始一个项目前, 一般会封装一个统一的 ajax 请求方法, 这样便于后面的修改, 但如果万一你没有封装, 并且已经开发了一大半了, 那就需要使用全局修改的方式. 答: 比方: 增加请求头部认证 bui.config.ajax = { headers: { token: \"\", }, }; 这个全局配置,每个控件都有一个,配置以后,会覆盖控件的默认参数. 样式问题 Bingotouch,Link 轻应用开发 Q: 安卓 9 的系统下,打开 link 轻应用市场会有页面白屏. ?> 在 index.js 加入这段代码可以解决白屏问题. 答: $(function () { var clientWidth = document.documentElement.clientWidth; if (clientWidth == 0) { window.location.reload(); } }); Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 17:39:41 "},"article.html":{"url":"article.html","title":"BUI 专栏","keywords":"","body":"BUI 专栏 订阅号 这是我们的订阅号, 专注 BUI App 移动开发, 会陆续在这整理一些相关的文章跟案例, 码字不易, 欢迎关注一波. BUI 技巧 【快速开发 App 实战】BUI 高仿网易新闻 App 系列一、搭建 App 开发环境和工作空间 @王小o BUI Webapp 跨平台框架 1.6 新版功能盘点 @王小o 【BUI 实战篇】好快, 1 分钟开发好一个下拉刷新,滚动加载列表 @王小o 【BUI 实战篇】BUI 数据驱动做的拼图游戏 Webapp 移动适配版，基于 vuejs 拼图游戏改造 @王小o 一张脑图看懂 BUI Webapp 移动快速开发框架【上】--框架与工具、资源 @王小o 一张脑图看懂 BUI Webapp 移动快速开发框架【下】--快速入门指引 @王小o webapp 结合 Dcloud 平台打包图文教程 @王小o 微信 Webapp 开发的各种变态路由需求及解决办法! @王小o BUI Webapp 用于项目中的一点小心得 @nian 2018 开发最快的 Webapp 框架--BUI 交互框架 @王小o BUI+Cordova BUI 框架中使用 Cordvoa 插件，集成微信跟支付宝支付 @伊何底止丶 BUI 框架中 使用 Jpush 极光推送，单推跟群推，尽量让小白都能看懂 @伊何底止丶 Cordova 项目 IphoneX 适配，结合 BUI 前端框架项目（需要修改原生代码） @伊何底止丶 Cordova 项目中使用 BUI 框架，以及常见问题解答 @伊何底止丶 Copyright &copy2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 17:37:26 "},"linkapi.html":{"url":"linkapi.html","title":"Link 专栏","keywords":"","body":"LINK API Link API 为原生开发平台, 供 Link 轻应用原生开发使用. Link API PC Link 平台相关文件 常见问题 Q: 安卓 9 的系统下,第二次打开 link 轻应用市场会有页面白屏. 更新 bui.css bui.js 为1.5.2版本以上 buijs update -p bingotouch Q: bui.isWebapp = false; 代表什么? 首先, 创建平台的时候, 要选择 buijs create -p bingotouch 这样创建的 bui.js 才是支持false形态. 这是因为移动端跟 PC 端的执行时机不同, 通过设置为 false 以后, bui.ready 会走原生的初始化时机, 确保原生设备的 API 已经准备就绪. 1.5 以前的版本, 这样设置以后, bui.ajax 会走原生请求, 1.5 以后的版本, 默认不管状态是什么, 都走 $.ajax ,打包后没有跨域问题. 按照工程配置去修改, 在手机端的调试也不会有跨域问题. Q: 如何与 LINK SSO 对接? 检查 index.html 有没有引入以下文件. 有引入说明已经是 bingotouch 工程了. 在工程下执行以下命令, 更新 bui.js 为 bingotouch 平台版本; buijs update -p bingotouch 切换 bui.isWebapp 的状态为 false; // 切换为原生, 走 deviceready. pc调试改为 true; bui.isWebapp = false; // 修改请求使用原生, 就会自动对接LINK SSO, 请求自动带上token; bui.config.ajax = { needNative: !bui.isWebapp, }; // 修改list请求使用原生, 就会自动对接LINK SSO, 请求自动带上token; bui.config.list = { needNative: !bui.isWebapp, }; bui.ready(function () { // 这个方法只能在link里面获取到, 在PC会报错, 请使用 try catch 包裹. app.link.getLoginInfo(function (result) { // 获取用户信息 bui.alert(result); }); }); 备用方案: 如果第 1 步检查不到这些依赖跟文件, 执行以下命令创建一个新工程, 把 index.html及 js/bui.js文件,js/platform目录 复制到自己的工程. 并重复第 2 步就行. // 创建新bingotouch工程, index.html里面会有对应的依赖文件, 并且bui.js会更新为bingotouch平台版本, 复制到你的工程下. buijs create -p bingotouch Copyright ©2017-2022 easybui.com all right reserved，powered by Gitbook该文件修订时间： 2022-08-17 11:27:40 "}}